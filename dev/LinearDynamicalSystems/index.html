<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Dynamical Systems · StateSpaceDynamics.jl</title><meta name="title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta property="og:title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta property="twitter:title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta name="description" content="Documentation for StateSpaceDynamics.jl."/><meta property="og:description" content="Documentation for StateSpaceDynamics.jl."/><meta property="twitter:description" content="Documentation for StateSpaceDynamics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="StateSpaceDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">StateSpaceDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Models</span><ul><li class="is-active"><a class="tocitem" href>Linear Dynamical Systems</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#The-Gaussian-Linear-Dynamical-System"><span>The Gaussian Linear Dynamical System</span></a></li><li class="toplevel"><a class="tocitem" href="#The-Poisson-Linear-Dynamical-System"><span>The Poisson Linear Dynamical System</span></a></li><li class="toplevel"><a class="tocitem" href="#Inference-in-Linear-Dynamical-Systems"><span>Inference in Linear Dynamical Systems</span></a></li><li><a class="tocitem" href="#Newton&#39;s-Method-for-Latent-State-Optimization"><span>Newton&#39;s Method for Latent State Optimization</span></a></li><li class="toplevel"><a class="tocitem" href="#Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models"><span>Laplace Approximation of Posterior for Non-Conjugate Observation Models</span></a></li><li class="toplevel"><a class="tocitem" href="#Learning-in-Linear-Dynamical-Systems"><span>Learning in Linear Dynamical Systems</span></a></li></ul></li><li><a class="tocitem" href="../HiddenMarkovModels/">Hidden Markov Models</a></li><li><a class="tocitem" href="../SLDS/">Switching Linear Dynamical Systems</a></li><li><a class="tocitem" href="../EmissionModels/">EmissionModels</a></li><li><a class="tocitem" href="../MixtureModels/">Mixture Models</a></li></ul></li><li><a class="tocitem" href="../Misc/">Miscellaneous</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Models</a></li><li class="is-active"><a href>Linear Dynamical Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Dynamical Systems</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="What-is-a-Linear-Dynamical-System?"><a class="docs-heading-anchor" href="#What-is-a-Linear-Dynamical-System?">What is a Linear Dynamical System?</a><a id="What-is-a-Linear-Dynamical-System?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-Linear-Dynamical-System?" title="Permalink"></a></h1><p>A <strong>Linear Dynamical System (LDS)</strong> is a mathematical model used to describe how a system evolves over time. These systems are a subset of <strong>state-space models</strong>, where the hidden state dynamics are continuous. What makes these models <em>linear</em> is that the latent dynamics evolve according to a linear function of the previous state. The observations, however, can be related to the hidden state through a nonlinear link function.</p><p>At its core, an LDS defines:</p><ul><li><strong>A state transition function</strong>: how the internal state evolves from one time step to the next.</li><li><strong>An observation function</strong>: how the internal state generates the observed data.</li></ul><h1 id="The-Gaussian-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#The-Gaussian-Linear-Dynamical-System">The Gaussian Linear Dynamical System</a><a id="The-Gaussian-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#The-Gaussian-Linear-Dynamical-System" title="Permalink"></a></h1><p>The <strong>Gaussian Linear Dynamical System</strong> — typically just referred to as an LDS — is a specific type of linear dynamical system where both the state transition and observation functions are linear, and all noise is Gaussian.</p><p>The generative model is given by:</p><p class="math-container">\[\begin{align*}
    x_t &amp;\sim \mathcal{N}(A x_{t-1}, Q) \\
    y_t &amp;\sim \mathcal{N}(C x_t, R)
\end{align*}\]</p><p>Where:</p><ul><li><span>$x_t$</span> is the hidden state at time <span>$t$</span></li><li><span>$y_t$</span> is the observed data at time <span>$t$</span></li><li><span>$\mathbf{A}$</span> is the state transition matrix</li><li><span>$\mathbf{C}$</span> is the observation matrix</li><li><span>$\mathbf{Q}$</span> is the process noise covariance</li><li><span>$\mathbf{R}$</span> is the observation noise covariance</li></ul><p>This can equivalently be written in equation form:</p><p class="math-container">\[\begin{align*}
    x_t &amp;= A x_{t-1} + \epsilon_t \\
    y_t &amp;= C x_t + \eta_t
\end{align*}\]</p><p>Where:</p><ul><li><span>$\epsilon_t \sim \mathcal{N}(0, Q)$</span> is the process noise</li><li><span>$\eta_t \sim \mathcal{N}(0, R)$</span> is the observation noise</li></ul><h1 id="The-Poisson-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#The-Poisson-Linear-Dynamical-System">The Poisson Linear Dynamical System</a><a id="The-Poisson-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#The-Poisson-Linear-Dynamical-System" title="Permalink"></a></h1><p>The <strong>Poisson Linear Dynamical System</strong> is a variant of the LDS where the observations are modeled as counts. This is useful in useful in fields like neuroscience where we are often interested in modeling spike count data. To relate the spiking data to the Gaussian latent variable, we use a nonlinear link function, specifically the exponential function. Thus our generative model is given by: </p><p class="math-container">\[\begin{align*}
    x_t &amp;\sim \mathcal{N}(A x_{t-1}, Q) \\
    y_t &amp;\sim \text{Poisson}(\text{exp}(Cx_t + b))
\end{align*}\]</p><p>Where:</p><ul><li><span>$\mathbf{b}$</span> is a bias term</li></ul><h1 id="Inference-in-Linear-Dynamical-Systems"><a class="docs-heading-anchor" href="#Inference-in-Linear-Dynamical-Systems">Inference in Linear Dynamical Systems</a><a id="Inference-in-Linear-Dynamical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Inference-in-Linear-Dynamical-Systems" title="Permalink"></a></h1><p>In StateSpaceDynamics.jl, we directly maximize the complete-data log-likelihood function with respect to the latent states given the data and the parameters of the model. In other words, the <strong>maximum a priori</strong> (MAP) estimate of the latent state path is:</p><p class="math-container">\[\underset{x}{\text{argmax}}  \left[ \log p(x_0) + \sum_{t=2}^T \log p(x_t \mid x_{t-1}) + \sum_{t=1}^T \log p(y_t \mid x_t) \right]\]</p><p>This MAP estimation approach has the same computational complexity as traditional Kalman filtering and smoothing — $ \mathcal{O}(T) $ — but is significantly more flexible. Notably, it can handle <strong>nonlinear observations</strong> and <strong>non-Gaussian noise</strong> while still yielding <strong>exact MAP estimates</strong>, unlike approximate techniques such as the Extended Kalman Filter (EKF) or Unscented Kalman Filter (UKF).</p><h2 id="Newton&#39;s-Method-for-Latent-State-Optimization"><a class="docs-heading-anchor" href="#Newton&#39;s-Method-for-Latent-State-Optimization">Newton&#39;s Method for Latent State Optimization</a><a id="Newton&#39;s-Method-for-Latent-State-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Newton&#39;s-Method-for-Latent-State-Optimization" title="Permalink"></a></h2><p>To find the MAP trajectory, we iteratively optimize the latent states using Newton’s method. The update equation at each iteration is:</p><p class="math-container">\[x^{(i+1)} = x^{(i)} - \left[ \nabla^2 \mathcal{L}(x^{(i)}) \right]^{-1} \nabla \mathcal{L}(x^{(i)})\]</p><p>Where:</p><ul><li><span>$\mathcal{L}(x)$</span> is the complete-data log-likelihood:</li></ul><p class="math-container">\[\mathcal{L}(x) = \log p(x_0) + \sum_{t=2}^T \log p(x_t \mid x_{t-1}) + \sum_{t=1}^T \log p(y_t \mid x_t)\]</p><ul><li><span>$\nabla \mathcal{L}(x)$</span> is the gradient of the full log-likelihood with respect to all latent states,</li><li><span>$\nabla^2 \mathcal{L}(x)$</span> is the Hessian of the full log-likelihood.</li></ul><p>This update is performed over the entire latent state sequence $ x_{1:T} $, and repeated until convergence.</p><p>For <strong>Gaussian models</strong>, <span>$\mathcal{L}(x)$</span> is quadratic and Newton&#39;s method converges in a single step — recovering the exact Kalman smoother solution. But, for <strong>non-Gaussian models</strong>, the Hessian is not constant and the optimization is more complex. However, the MAP estimate can still be computed efficiently using the same approach as the optimization problem is still convex.</p><h1 id="Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models"><a class="docs-heading-anchor" href="#Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models">Laplace Approximation of Posterior for Non-Conjugate Observation Models</a><a id="Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models" title="Permalink"></a></h1><p>In the case of non-Gaussian observations, we can use a Laplace approximation to compute the posterior distribution of the latent states. Notably, in the case of Gaussian Observations (which is conjugate with the Gaussian state model), the posterior is also Gaussian, and is the exact posterior. However, for non-Gaussian observations, we can approximate the posterior using a Gaussian distribution centered at the MAP estimate of the latent states. This approximation is given by:</p><p class="math-container">\[p(x \mid y) \approx \mathcal{N}(x^{(*)}, -\left[ \nabla^2 \mathcal{L}(x^{(*)}) \right]^{-1})\]</p><p>Where:</p><ul><li><span>$x^{(*)}$</span> is the MAP estimate of the latent states</li><li><span>$\nabla^2 \mathcal{L}(x^{(*)})$</span> is the Hessian of the log-likelihood at the MAP estimate.</li></ul><p>Despite, the requirement of inverting a Hessian of diomension (d x T) x (d x T), this is still computationally efficient, as the Markov structure of the model, renders the Hessian block-tridiagonal, and thus the inversion is not intractable.</p><h1 id="Learning-in-Linear-Dynamical-Systems"><a class="docs-heading-anchor" href="#Learning-in-Linear-Dynamical-Systems">Learning in Linear Dynamical Systems</a><a id="Learning-in-Linear-Dynamical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Learning-in-Linear-Dynamical-Systems" title="Permalink"></a></h1><p>Given the latent structure of state-space models, we must rely on either the Expectation-Maximization (EM) or Variational Inference (VI) approaches to learn the parameters of the model. StateSpaceDynamics.jl supports both EM and VI. For LDS models, we can use Laplace EM, where we approximate the posterior of the latent state path using the Laplace approximation as outlined above. Using these approximate posteriors (or exact ones in the Gaussian case), we can apply closed-form updates for the model parameters.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianObservationModel" href="#StateSpaceDynamics.GaussianObservationModel"><code>StateSpaceDynamics.GaussianObservationModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianObservationModel{T&lt;:Real} &lt;: AbstractObservationModel</code></pre><p>Represents the observation model of a Linear Dynamical System with Gaussian noise.</p><p><strong>Fields</strong></p><ul><li><code>C::Matrix{T}</code>: Observation matrix</li><li><code>R::Matrix{T}</code>: Observation noise covariance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.GaussianObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.GaussianObservationModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianObservationModel(; C, R, obs_dim, latent_dim)</code></pre><p>Construct a GaussianObservationModel with the given parameters or random initializations.</p><p><strong>Arguments</strong></p><ul><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>R::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation noise covariance</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if C or R is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianStateModel" href="#StateSpaceDynamics.GaussianStateModel"><code>StateSpaceDynamics.GaussianStateModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianStateModel{T&lt;:Real} &lt;: AbstractStateModel</code></pre><p>Represents the state model of a Linear Dynamical System with Gaussian noise.</p><p><strong>Fields</strong></p><ul><li><code>A::Matrix{T}</code>: Transition matrix</li><li><code>Q::Matrix{T}</code>: Process noise covariance</li><li><code>x0::Vector{T}</code>: Initial state</li><li><code>P0::Matrix{T}</code>: Initial state covariance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianStateModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.GaussianStateModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.GaussianStateModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianStateModel(; A, Q, x0, P0, latent_dim)</code></pre><p>Construct a GaussianStateModel with the given parameters or random initializations.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Transition matrix</li><li><code>Q::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Process noise covariance</li><li><code>x0::Vector{T}=Vector{T}(undef, 0)</code>: Initial state</li><li><code>P0::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Initial state covariance</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if any matrix is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.LinearDynamicalSystem" href="#StateSpaceDynamics.LinearDynamicalSystem"><code>StateSpaceDynamics.LinearDynamicalSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearDynamicalSystem{S&lt;:AbstractStateModel, O&lt;:AbstractObservationModel}</code></pre><p>Represents a unified Linear Dynamical System with customizable state and observation models.</p><p><strong>Fields</strong></p><ul><li><code>state_model::S</code>: The state model (e.g., GaussianStateModel)</li><li><code>obs_model::O</code>: The observation model (e.g., GaussianObservationModel or PoissonObservationModel)</li><li><code>latent_dim::Int</code>: Dimension of the latent state</li><li><code>obs_dim::Int</code>: Dimension of the observations</li><li><code>fit_bool::Vector{Bool}</code>: Vector indicating which parameters to fit during optimization</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonObservationModel" href="#StateSpaceDynamics.PoissonObservationModel"><code>StateSpaceDynamics.PoissonObservationModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonObservationModel{T&lt;:Real} &lt;: AbstractObservationModel</code></pre><p>Represents the observation model of a Linear Dynamical System with Poisson observations.</p><p><strong>Fields</strong></p><ul><li><code>C::Matrix{T}</code>: Observation matrix</li><li><code>log_d::Vector{T}</code>: Mean firing rate vector (log space)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.PoissonObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.PoissonObservationModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonObservationModel(; C, log_d, obs_dim, latent_dim)</code></pre><p>Construct a PoissonObservationModel with the given parameters or random initializations.</p><p><strong>Arguments</strong></p><ul><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>log_d::Vector{T}=Vector{T}(undef, 0)</code>: Mean firing rate vector (log space)</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if any matrix is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.GaussianLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.GaussianLDS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianLDS(; A, C, Q, R, x0, P0, fit_bool, obs_dim, latent_dim)</code></pre><p>Construct a Linear Dynamical System with Gaussian state and observation models.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Transition matrix</li><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>Q::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Process noise covariance</li><li><code>R::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation noise covariance</li><li><code>x0::Vector{T}=Vector{T}(undef, 0)</code>: Initial state</li><li><code>P0::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Initial state covariance</li><li><code>fit_bool::Vector{Bool}=fill(true, 6)</code>: Vector indicating which parameters to fit during optimization</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if C or R is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if A, Q, x0, P0, or C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.Gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient(lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}, x::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Compute the gradient of the log-likelihood with respect to the latent states for a linear dynamical system.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li><li><code>y::AbstractMatrix{T}</code>: The observed data.</li><li><code>x::AbstractMatrix{T}</code>: The latent states.</li><li><code>w::Vector{Float64}</code>: coeffcients to weight the data.</li></ul><p><strong>Returns</strong></p><ul><li><code>grad::Matrix{T}</code>: Gradient of the log-likelihood with respect to the latent states.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}, Vector{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}, Vector{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.Gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient(lds::LinearDynamicalSystem{S,O}, y::Matrix{T}, x::Matrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the gradient of the log-likelihood of a Poisson Linear Dynamical System model for a single trial.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>y::Matrix{T}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps)</li><li><code>x::Matrix{T}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>steps)</li><li><code>w::Vector{T}</code>: Weights for each observation in the log-likelihood calculation. Not currently used.</li></ul><p><strong>Returns</strong></p><ul><li><code>grad::Matrix{T}</code>: The gradient of the log-likelihood. Dimensions: (latent<em>dim, T</em>steps)</li></ul><p><strong>Note</strong></p><p>The gradient is computed with respect to the latent states x. Each row of the returned gradient corresponds to the gradient for a single time step.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.Hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessian(lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}, x::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Construct the Hessian matrix of the log-likelihood of the LDS model given a set of observations.</p><p>This function is used for the direct optimization of the log-likelihood as advocated by Paninski et al. (2009).  The block tridiagonal structure of the Hessian is exploited to reduce the number of parameters that need to be computed, and to reduce the memory requirements. Together with the gradient, this allows for Kalman Smoothing to be performed  by simply solving a linear system of equations:</p><pre><code class="nohighlight hljs">̂xₙ₊₁ = ̂xₙ - H \ ∇</code></pre><p>where ̂xₙ is the current smoothed state estimate, H is the Hessian matrix, and ∇ is the gradient of the log-likelihood.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li><li><code>y::AbstractMatrix{T}</code>: Matrix of observations.</li><li><code>x::AbstractMatrix{T}</code>: Matrix of latent states.</li><li><code>w::Vector{Float64}</code>: coeffcients to weight the data.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::Matrix{T}</code>: Hessian matrix of the log-likelihood.</li><li><code>H_diag::Vector{Matrix{T}}</code>: Main diagonal blocks of the Hessian.</li><li><code>H_super::Vector{Matrix{T}}</code>: Super-diagonal blocks of the Hessian.</li><li><code>H_sub::Vector{Matrix{T}}</code>: Sub-diagonal blocks of the Hessian.</li></ul><p><strong>Note</strong></p><ul><li><code>x</code> is not used in this function, but is required to match the function signature of other Hessian calculations e.g., in PoissonLDS.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}, Vector{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}, Vector{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.Hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessian(lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}, x::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the Hessian matrix of the log-likelihood for a Poisson Linear Dynamical System.</p><p>This function computes the Hessian matrix, which represents the second-order partial derivatives of the log-likelihood with respect to the latent states.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System with Poisson observations.</li><li><code>y::AbstractMatrix{T}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps)</li><li><code>x::AbstractMatrix{T}</code>: The current estimate of latent states. Dimensions: (latent<em>dim, T</em>steps)</li><li><code>w::Vector{T}</code>: Weights for each observation in the log-likelihood calculation. Not currently used.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::Matrix{T}</code>: The full Hessian matrix.</li><li><code>H_diag::Vector{Matrix{T}}</code>: The main diagonal blocks of the Hessian.</li><li><code>H_super::Vector{Matrix{T}}</code>: The super-diagonal blocks of the Hessian.</li><li><code>H_sub::Vector{Matrix{T}}</code>: The sub-diagonal blocks of the Hessian.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.PoissonLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.PoissonLDS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonLDS(; A, C, Q, log_d, x0, P0, refractory_period, fit_bool, obs_dim, latent_dim)</code></pre><p>Construct a Linear Dynamical System with Gaussian state and Poisson observation models.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Transition matrix</li><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>Q::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Process noise covariance</li><li><code>log_d::Vector{T}=Vector{T}(undef, 0)</code>: Mean firing rate vector (log space)</li><li><code>x0::Vector{T}=Vector{T}(undef, 0)</code>: Initial state</li><li><code>P0::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Initial state covariance</li><li><code>refractory_period::Int=1</code>: Refractory period</li><li><code>fit_bool::Vector{Bool}=fill(true, 7)</code>: Vector indicating which parameters to fit during optimization</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if C, D, or log_d is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if A, Q, x0, P0, or C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_function" href="#StateSpaceDynamics.Q_function"><code>StateSpaceDynamics.Q_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q(A, Q, H, R, P0, x0, E_z, E_zz, E_zz_prev, y)</code></pre><p>Calculate the complete Q-function for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{&lt;:Real}</code>: The state transition matrix.</li><li><code>Q::AbstractMatrix{&lt;:Real}</code>: The process noise covariance matrix (or its Cholesky factor).</li><li><code>H::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>R::AbstractMatrix{&lt;:Real}</code>: The observation noise covariance matrix (or its Cholesky factor).</li><li><code>P0::AbstractMatrix{&lt;:Real}</code>: The initial state covariance matrix (or its Cholesky factor).</li><li><code>x0::Vector{&lt;:Real}</code>: The initial state mean.</li><li><code>E_z::Matrix{&lt;:Real}</code>: The expected latent states, size (state_dim, T).</li><li><code>E_zz::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>E_zz_prev::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>y::Matrix{&lt;:Real}</code>: The observed data, size (obs_dim, T).</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_val::Float64</code>: The complete Q-function value.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_function-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Vector{T}, Matrix{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where T&lt;:Real" href="#StateSpaceDynamics.Q_function-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Vector{T}, Matrix{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where T&lt;:Real"><code>StateSpaceDynamics.Q_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_function(A::Matrix{T}, Q::Matrix{T}, C::Matrix{T}, log_d::Vector{T}, x0::Vector{T}, P0::Matrix{T}, E_z::Matrix{T}, E_zz::Array{T, 3}, E_zz_prev::Array{T, 3}, P_smooth::Array{T, 3}, y::Matrix{T})</code></pre><p>Calculate the Q-function for the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}</code>: The transition matrix.</li><li><code>Q::Matrix{T}</code>: The process noise covariance matrix.</li><li><code>C::Matrix{T}</code>: The observation matrix.</li><li><code>log_d::Vector{T}</code>: The mean firing rate vector in log space.</li><li><code>x0::Vector{T}</code>: The initial state mean.</li><li><code>P0::Matrix{T}</code>: The initial state covariance matrix.</li><li><code>E_z::Matrix{T}</code>: The expected latent states.</li><li><code>E_zz::Array{T, 3}</code>: The expected latent states x the latent states.</li><li><code>E_zz_prev::Array{T, 3}</code>: The expected latent states x the previous latent states.</li><li><code>P_smooth::Array{T, 3}</code>: The smoothed state covariances.</li><li><code>y::Matrix{T}</code>: The observed data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Q-function for the Linear Dynamical System.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_obs" href="#StateSpaceDynamics.Q_obs"><code>StateSpaceDynamics.Q_obs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_obs(H, R, E_z, E_zz, y)</code></pre><p>Calculate the observation component of the Q-function for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>R::AbstractMatrix{&lt;:Real}</code>: The observation noise covariance matrix (or its Cholesky factor).</li><li><code>E_z::Matrix{&lt;:Real}</code>: The expected latent states, size (state_dim, T).</li><li><code>E_zz::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>y::Matrix{&lt;:Real}</code>: The observed data, size (obs_dim, T).</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_val::Float64</code>: The observation component of the Q-function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_obs-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#StateSpaceDynamics.Q_obs-Tuple{AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>StateSpaceDynamics.Q_obs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_obs(H, R, E_z, E_zz, y)</code></pre><p>Calculate the a single time step observation component of the Q-function for the EM algorithm in a Linear Dynamical System before the R^-1 is accounted for.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>R::AbstractMatrix{&lt;:Real}</code>: The observation noise covariance matrix (or its Cholesky factor).</li><li><code>E_z::Vector{&lt;:Real}</code>: The expected latent states at time t, size (state_dim).</li><li><code>E_zz::Matrix{&lt;:Real}</code>: The expected value of z<em>t * z</em>t&#39; at time t, size (state<em>dim, state</em>dim).</li><li><code>y::Vector{&lt;:Real}</code>: The observed data at time t, size (obs_dim).</li></ul><p><strong>Returns</strong></p><ul><li><code>q::Float64</code>: The observation component at time t of the Q-function prior to R^-1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_observation_model-Union{Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractArray{U, 3}, AbstractArray{U, 4}, Array{U, 3}}} where {T&lt;:Real, U&lt;:Real}" href="#StateSpaceDynamics.Q_observation_model-Union{Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractArray{U, 3}, AbstractArray{U, 4}, Array{U, 3}}} where {T&lt;:Real, U&lt;:Real}"><code>StateSpaceDynamics.Q_observation_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_observation_model(C::Matrix{&lt;:Real}, D::Matrix{&lt;:Real}, log_d::Vector{&lt;:Real}, E_z::Array{&lt;:Real}, E_zz::Array{&lt;:Real}, y::Array{&lt;:Real})</code></pre><p>Calculate the Q-function for the observation model.</p><p><strong>Arguments</strong></p><ul><li><code>C::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>log_d::Vector{&lt;:Real}</code>: The mean firing rate vector in log space.</li><li><code>E_z::Array{&lt;:Real}</code>: The expected latent states.</li><li><code>E_zz::Array{&lt;:Real}</code>: The expected latent states x the latent states.</li><li><code>y::Array{&lt;:Real}</code>: The observed data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Q-function for the observation model.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_state-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractArray{&lt;:Real, 3}}" href="#StateSpaceDynamics.Q_state-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractArray{&lt;:Real, 3}}"><code>StateSpaceDynamics.Q_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_state(A, Q, P0, x0, E_z, E_zz, E_zz_prev)</code></pre><p>Calculate the state component of the Q-function for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{&lt;:Real}</code>: The state transition matrix.</li><li><code>Q::AbstractMatrix{&lt;:Real}</code>: The process noise covariance matrix (or its Cholesky factor).</li><li><code>P0::AbstractMatrix{&lt;:Real}</code>: The initial state covariance matrix (or its Cholesky factor).</li><li><code>x0::Vector{&lt;:Real}</code>: The initial state mean.</li><li><code>E_z::Matrix{&lt;:Real}</code>: The expected latent states, size (state_dim, T).</li><li><code>E_zz::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>E_zz_prev::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T).</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_val::Float64</code>: The state component of the Q-function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_state-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real" href="#StateSpaceDynamics.Q_state-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real"><code>StateSpaceDynamics.Q_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_state(A::Matrix{T}, Q::Matrix{T}, P0::Matrix{T}, x0::Vector{T}, E_z::Array{T, 3}, E_zz::Array{T, 4}, E_zz_prev::Array{T, 4}) where T&lt;:Real</code></pre><p>Calculates the Q-function for the state model over multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}</code>: The transition matrix.</li><li><code>Q::Matrix{T}</code>: The process noise covariance matrix.</li><li><code>P0::Matrix{T}</code>: The initial state covariance matrix.</li><li><code>x0::Vector{T}</code>: The initial state mean.</li><li><code>E_z::Array{T, 3}</code>: The expected latent states.</li><li><code>E_zz::Array{T, 4}</code>: The expected latent states x the latent states.</li><li><code>E_zz_prev::Array{T, 4}</code>: The expected latent states x the previous latent states.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Q-function for the state model.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.calculate_elbo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_elbo(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, E_zz_prev::Array{T,4}, p_smooth::Array{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Calculate the Evidence Lower Bound (ELBO) for a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Returns</strong></p><ul><li><code>elbo::T</code>: The Evidence Lower Bound (ELBO) for the LDS.</li></ul><p><strong>Note</strong></p><ul><li>For a GaussianLDS the ELBO is equivalent to the total marginal likelihood</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.calculate_elbo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_elbo(plds::LinearDynamicalSystem{S,O}, E_z::Array{T, 3}, E_zz::Array{T, 4}, 
               E_zz_prev::Array{T, 4}, P_smooth::Array{T, 4}, y::Array{T, 3}) where 
               {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the Evidence Lower Bound (ELBO) for a Poisson Linear Dynamical System (PLDS).</p><p><strong>Arguments</strong></p><ul><li><code>plds::LinearDynamicalSystem{S,O}</code>: The PLDS model.</li><li><code>E_z::Array{T, 3}</code>: Expected values of latent states. Dimensions: (state<em>dim, t</em>steps, n_trials).</li><li><code>E_zz::Array{T, 4}</code>: Expected values of latent state outer products. Dimensions: (state<em>dim, state</em>dim, t<em>steps, n</em>trials).</li><li><code>E_zz_prev::Array{T, 4}</code>: Expected values of latent state outer products with previous time step. Dimensions: (state dimension, state dimension, t<em>steps-1, n</em>trials).</li><li><code>P_smooth::Array{T, 4}</code>: Smoothed covariance matrices. Dimensions: (state dimension, state dimension, t<em>steps, n</em>trials).</li><li><code>y::Array{T, 3}</code>: Observed data. Dimensions: (obs<em>dim, t</em>steps, n_trials).</li></ul><p><strong>Returns</strong></p><ul><li><code>elbo::Float64</code>: The calculated Evidence Lower Bound.</li></ul><p><strong>Description</strong></p><p>This function computes the ELBO for a PLDS model, which consists of two main components:</p><ol><li>The expected complete log-likelihood (ECLL), calculated using the Q_function.</li><li>The entropy of the variational distribution, calculated using gaussian entropy.</li></ol><p>The ELBO is then computed as: ELBO = ECLL - Entropy.</p><p><strong>Note</strong></p><p>Ensure that the dimensions of input arrays match the expected dimensions as described in the arguments section.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.estep-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.estep-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.estep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estep(lds::LinearDynamicalSystem{S,O}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Perform the E-step of the EM algorithm for a Linear Dynamical System, treating all input as multi-trial.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n<em>trials)   Note: For single-trial data, use y[1:1, :, :] to create a 3D array with n</em>trials = 1</li></ul><p><strong>Returns</strong></p><ul><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>x_smooth::Array{T,3}</code>: Smoothed state estimates, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>ml::T</code>: Total marginal likelihood (log-likelihood) of the data across all trials</li></ul><p><strong>Note</strong></p><ul><li>This function first smooths the data using the <code>smooth</code> function, then computes sufficient statistics.</li><li>It treats all input as multi-trial, with single-trial being a special case where n_trials = 1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.fit!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.fit!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.fit!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit!(lds::LinearDynamicalSystem{S,O}, y::Matrix{T}; 
     max_iter::Int=1000, 
     tol::Real=1e-12, 
     ) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Fit a Linear Dynamical System using the Expectation-Maximization (EM) algorithm with Kalman smoothing.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System to be fitted.</li><li><code>y::Matrix{T}</code>: Observed data, size (obs<em>dim, T</em>steps).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>max_iter::Int=1000</code>: Maximum number of EM iterations.</li><li><code>tol::Real=1e-12</code>: Convergence tolerance for log-likelihood change.</li></ul><p><strong>Returns</strong></p><ul><li><code>mls::Vector{T}</code>: Vector of log-likelihood values for each iteration.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.gradient_observation_model!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractArray{T}, AbstractArray{T}, Array{T}}} where T&lt;:Real" href="#StateSpaceDynamics.gradient_observation_model!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractArray{T}, AbstractArray{T}, Array{T}}} where T&lt;:Real"><code>StateSpaceDynamics.gradient_observation_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_observation_model!(grad::AbstractVector{T}, C::AbstractMatrix{T}, log_d::AbstractVector{T}, E_z::AbstractArray{T}, P_smooth::AbstractArray{T}, y::Array{T}) where T&lt;:Real</code></pre><p>Compute the gradient of the Q-function with respect to the observation model parameters (C and log_d) for a Poisson Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>grad::AbstractVector{T}</code>: Pre-allocated vector to store the computed gradient.</li><li><code>C::AbstractMatrix{T}</code>: The observation matrix. Dimensions: (obs<em>dim, latent</em>dim)</li><li><code>log_d::AbstractVector{T}</code>: The log of the baseline firing rates. Dimensions: (obs_dim,)</li><li><code>E_z::AbstractArray{T}</code>: The expected latent states. Dimensions: (latent<em>dim, t</em>steps, n_trials)</li><li><code>P_smooth::AbstractArray{T}</code>: The smoothed state covariances. Dimensions: (latent<em>dim, latent</em>dim, t<em>steps, n</em>trials)</li><li><code>y::Array{T}</code>: The observed data. Dimensions: (obs<em>dim, t</em>steps, N-trials)</li></ul><p><strong>Note</strong></p><p>This function modifies <code>grad</code> in-place. The gradient is computed for the negative Q-function, as we&#39;re minimizing -Q in optimization routines.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.initialize_FilterSmooth-Tuple{StateSpaceDynamics.LinearDynamicalSystem, Int64}" href="#StateSpaceDynamics.initialize_FilterSmooth-Tuple{StateSpaceDynamics.LinearDynamicalSystem, Int64}"><code>StateSpaceDynamics.initialize_FilterSmooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_FilterSmooth(model::LinearDynamicalSystem, num_obs::Int) -&gt; FilterSmooth{T}</code></pre><p>Initialize a <code>FilterSmooth</code> object for a given linear dynamical system model and number of observations.</p><p><strong>Arguments</strong></p><ul><li><p><code>model::LinearDynamicalSystem</code>:   The linear dynamical system model containing system parameters, including the latent dimensionality (<code>latent_dim</code>).</p></li><li><p><code>num_obs::Int</code>:   The number of observations (time steps) for which to initialize the smoothing filters.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>FilterSmooth{T}</code>:   A <code>FilterSmooth</code> instance with all fields initialized to zero arrays. The dimensions of the arrays are determined by the number of states (<code>latent_dim</code>) from the model and the specified number of observations (<code>num_obs</code>).</li></ul><p><strong>Example</strong></p><p>```julia</p><p><strong>Assume <code>model</code> is an instance of LinearDynamicalSystem with latent_dim = 10</strong></p><p>num<em>observations = 100 filter</em>smooth = initialize<em>FilterSmooth(model, num</em>observations)</p><p><strong><code>filter_smooth</code> now contains zero-initialized arrays for smoothing operations</strong></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Array{T, 3}, StateSpaceDynamics.LinearDynamicalSystem{O, S}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Array{T, 3}, StateSpaceDynamics.LinearDynamicalSystem{O, S}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikelihood(x::Array{T, 3}, lds::LinearDynamicalSystem{S,O}, y::Array{T, 3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the complete-data log-likelihood of a Poisson Linear Dynamical System model for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{T, 3}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>y::Array{T, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Returns</strong></p><ul><li><code>ll::T</code>: The log-likelihood value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lds = PoissonLDS(obs_dim=4, latent_dim=3)
x, y = sample(lds, 100, 10)  # 10 trials, 100 time steps each
ll = loglikelihood(x, lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{U}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}, Vector{U}}} where {U&lt;:Real, T&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.PoissonObservationModel)}" href="#StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{U}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}, Vector{U}}} where {U&lt;:Real, T&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.PoissonObservationModel)}"><code>StateSpaceDynamics.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikelihood(x::Matrix{T}, lds::LinearDynamicalSystem{S,O}, y::Matrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel, O&lt;:PoissonObservationModel}</code></pre><p>Calculate the complete-data log-likelihood of a Poisson Linear Dynamical System model for a single trial. </p><p><strong>Arguments</strong></p><ul><li><code>x::Matrix{T}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>steps)</li><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>y::Matrix{T}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps)</li><li><code>w::Vector{T}</code>: Weights for each observation in the log-likelihood calculation. Not currently used.</li></ul><p><strong>Returns</strong></p><ul><li><code>ll::T</code>: The log-likelihood value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-juliaestep hljs">lds = PoissonLDS(obs_dim=4, latent_dim=3)
x, y = sample(lds, 100, 1)  # 1 trial, 100 time steps
ll = loglikelihood(x, lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}, Vector{Float64}}} where {T&lt;:Real, U&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.GaussianObservationModel)}" href="#StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}, Vector{Float64}}} where {T&lt;:Real, U&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.GaussianObservationModel)}"><code>StateSpaceDynamics.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikelihood(x::AbstractMatrix{T}, lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Calculate the complete-data log-likelihood of a linear dynamical system (LDS) given the observed data.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: The state sequence of the LDS.</li><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li><li><code>y::AbstractMatrix{T}</code>: The observed data.</li><li><code>w::Vector{Float64}</code>: coeffcients to weight the data.</li></ul><p><strong>Returns</strong></p><ul><li><code>ll::T</code>: The complete-data log-likelihood of the LDS.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.mstep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mstep!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, E_zz_prev::Array{T,4}, p_smooth::Array{T, 4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Perform the M-step of the EM algorithm for a Linear Dynamical System with multi-trial data.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials) (not used)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place by updating all model parameters.</li><li>Updates are performed only for parameters where the corresponding <code>fit_bool</code> is true.</li><li>All update functions now handle multi-trial data.</li><li>P_smooth is required but not used in the M-step so that the function signature matches the PoissonLDS version.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.mstep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mstep!(plds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, E_zz_Prev{T,4}, p_smooth{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Perform the M-step of the EM algorithm for a Poisson Linear Dynamical System with multi-trial data.</p><p><strong>Arguments</strong></p><ul><li><code>plds::LinearDynamicalSystem{S,O}</code>: The Poisson Linear Dynamical System struct.</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>plds</code> in-place by updating all model parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.obsparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}" href="#StateSpaceDynamics.obsparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}"><code>StateSpaceDynamics.obsparams</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obsparams(lds::LinearDynamicalSystem{S,O}) where {S&lt;:AbstractStateModel,O&lt;:AbstractObservationModel}</code></pre><p>Extract the observation parameters from a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li></ul><p><strong>Returns</strong></p><ul><li><code>params::Vector{Vector{Real}}</code>: Vector of observation parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(lds::LinearDynamicalSystem{S,O}, T_steps::Int, n_trials::Int) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Sample from a Linear Dynamical System (LDS) model for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>T_steps::Int</code>: The number of time steps to sample for each trial.</li><li><code>n_trials::Int</code>: The number of trials to sample.=</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{T, 3}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>y::Array{T, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lds = GaussianLDS(obs_dim=4, latent_dim=3)
x, y = sample(lds, 10, 100)  # 10 trials, 100 time steps each</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(lds::LinearDynamicalSystem{S,O}, T_steps::Int, n_trials::Int) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Sample from a Poisson Linear Dynamical System (LDS) model for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>T_steps::Int</code>: The number of time steps to sample for each trial.</li><li><code>n_trials::Int</code>: The number of trials to sample.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{T, 3}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>y::Array{Int, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lds = LinearDynamicalSystem(obs_dim=4, latent_dim=3)
x, y = sample(lds, 100, 10)  # 10 trials, 100 time steps each</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.smooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(lds::LinearDynamicalSystem{S,O}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>This function performs direct smoothing for a linear dynamical system (LDS) given the system parameters and the observed data for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The LDS object representing the system parameters.</li><li><code>y::Array{T,3}</code>: The observed data array with dimensions (obs<em>dim, tiem</em>steps, n_trials).</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{T,3}</code>: The optimal state estimates with dimensions (n<em>trials, time</em>steps, latent_dim).</li><li><code>p_smooth::Array{T,4}</code>: The posterior covariance matrices with dimensions (latent<em>dim, latent</em>dim, time<em>steps, n</em>trials).</li><li><code>inverse_offdiag::Array{T,4}</code>: The inverse off-diagonal matrices with dimensions (latent<em>dim, latent</em>dim, time<em>steps, n</em>trials).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lds = GaussianLDS(obs_dim=4, latent_dim=3)
y = randn(5, 100, 4)  # 5 trials, 100 time steps, 4 observed dimension
x, p_smooth, inverse_offdiag = smooth(lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.smooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(lds::LinearDynamicalSystem{S,O}, y::Matrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>This function performs direct smoothing for a linear dynamical system (LDS) given the system parameters and the observed data.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The LDS object representing the system parameters.</li><li><code>y::Matrix{T}</code>: The observed data matrix.</li><li><code>w::Vector{Float64}</code>: coeffcients to weight the data.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Matrix{T}</code>: The optimal state estimate.</li><li><code>p_smooth::Array{T, 3}</code>: The posterior covariance matrix.</li><li><code>inverse_offdiag::Array{T, 3}</code>: The inverse off-diagonal matrix.</li><li><code>Q_val::T</code>: The Q-function value.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lds = GaussianLDS(obs_dim=4, latent_dim=3)
y = randn(100, 4)  # 100 time steps, 4 observed dimensions
x, p_smooth, inverse_offdiag, Q_val = DirectSmoother(lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.stateparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}" href="#StateSpaceDynamics.stateparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}"><code>StateSpaceDynamics.stateparams</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stateparams(lds::LinearDynamicalSystem{S,O}) where {S&lt;:AbstractStateModel,O&lt;:AbstractObservationModel}</code></pre><p>Extract the state parameters from a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li></ul><p><strong>Returns</strong></p><ul><li><code>params::Vector{Vector{Real}}</code>: Vector of state parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.sufficient_statistics-Union{Tuple{T}, Tuple{Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real" href="#StateSpaceDynamics.sufficient_statistics-Union{Tuple{T}, Tuple{Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real"><code>StateSpaceDynamics.sufficient_statistics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sufficient_statistics(x_smooth::Array{T,3}, p_smooth::Array{T,4}, p_smooth_t1::Array{T,4}) where T &lt;: Real</code></pre><p>Compute sufficient statistics for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>x_smooth::Array{T,3}</code>: Smoothed state estimates, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>p_smooth_t1::Array{T,4}</code>: Lag-one covariance smoother, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li></ul><p><strong>Returns</strong></p><ul><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li></ul><p><strong>Note</strong></p><ul><li>The function computes the expected values for all trials.</li><li>For single-trial data, use inputs with n_trials = 1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_C!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.update_C!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.update_C!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_C!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Update the observation matrix C of the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[5]</code> is true.</li><li>The result is averaged across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_Q!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 4}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.update_Q!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 4}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.update_Q!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_Q!(lds::LinearDynamicalSystem{S,O}, E_zz::Array{T, 4}, E_zz_prev::Array{T, 4}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Update the process noise covariance matrix Q of the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_zz::Array{T, 4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz_prev::Array{T, 4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[4]</code> is true.</li><li>The result is averaged across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_R!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.update_R!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}, Vector{Float64}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.update_R!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_R!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Update the observation noise covariance matrix R of the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[6]</code> is true.</li><li>The result is averaged across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_initial_state_covariance!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.update_initial_state_covariance!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.update_initial_state_covariance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_initial_state_covariance!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Update the initial state covariance of the Linear Dynamical System using the average across all trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[2]</code> is true.</li><li>The initial state covariance is computed as the average of the first time step across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_initial_state_mean!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.update_initial_state_mean!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.update_initial_state_mean!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_initial_state_mean!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Update the initial state mean of the Linear Dynamical System using the average across all trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[1]</code> is true.</li><li>The initial state mean is computed as the average of the first time step across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_observation_model!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.update_observation_model!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.update_observation_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_observation_model!(plds::LinearDynamicalSystem{S,O}, E_z::Array{T, 3}, P_smooth::Array{T, 4}, y::Array{T, 3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Update the observation model parameters of a Poisson Linear Dynamical System using gradient-based optimization.</p><p><strong>Arguments</strong></p><ul><li><code>plds::LinearDynamicalSystem{S,O}</code>: The Poisson Linear Dynamical System model.</li><li><code>E_z::Array{T, 3}</code>: The expected latent states. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>P_smooth::Array{T, 4}</code>: The smoothed state covariances. Dimensions: (latent<em>dim, T</em>Steps, n<em>trials, latent</em>dim)</li><li><code>y::Array{T, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><p>This function modifies <code>plds</code> in-place by updating the observation model parameters (C and log<em>d). The optimization is performed only if `plds.fit</em>bool[5]` is true.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../HiddenMarkovModels/">Hidden Markov Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Wednesday 16 April 2025 20:11">Wednesday 16 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
