<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Dynamical Systems · StateSpaceDynamics.jl</title><meta name="title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta property="og:title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta property="twitter:title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta name="description" content="Documentation for StateSpaceDynamics.jl."/><meta property="og:description" content="Documentation for StateSpaceDynamics.jl."/><meta property="twitter:description" content="Documentation for StateSpaceDynamics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="StateSpaceDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">StateSpaceDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Models</span><ul><li class="is-active"><a class="tocitem" href>Linear Dynamical Systems</a><ul class="internal"><li><a class="tocitem" href="#Mathematical-Background"><span>Mathematical Background</span></a></li><li><a class="tocitem" href="#The-Filtering-Problem"><span>The Filtering Problem</span></a></li><li><a class="tocitem" href="#The-Smoothing-Problem"><span>The Smoothing Problem</span></a></li><li><a class="tocitem" href="#The-Prediction-Problem"><span>The Prediction Problem</span></a></li></ul></li><li><a class="tocitem" href="../HiddenMarkovModels/">Hidden Markov Models</a></li><li><a class="tocitem" href="../EmissionModels/">EmissionModels</a></li><li><a class="tocitem" href="../MixtureModels/">Mixture Models</a></li></ul></li><li><a class="tocitem" href="../Misc/">Miscellaneous</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Models</a></li><li class="is-active"><a href>Linear Dynamical Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Dynamical Systems</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LDS-Models"><a class="docs-heading-anchor" href="#LDS-Models">LDS Models</a><a id="LDS-Models-1"></a><a class="docs-heading-anchor-permalink" href="#LDS-Models" title="Permalink"></a></h1><h2 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h2><p>In the most general form, a linear dynamical system (LDS) is a state-space model with linear dynamics. This can be expressed as follows:</p><p class="math-container">\[\begin{align*}
x_{t+1} &amp;= f(x_t)\\
y_t &amp;= g(x_t)
\end{align*}\]</p><p>where <span>$x_t$</span> is the latent state at time <span>$t$</span>, <span>$y_t$</span> is the observed data at time <span>$t$</span>, <span>$f$</span> is the state transition function, <span>$g$</span> is the observation function. In the linear case, <span>$f$</span> and <span>$g$</span> are linear functions. The way we have written the above expression, we haven&#39;t made an explicit statement about the noise distribution–and this is on purpose. While the classic Linear-Gaussian Dynamical System (i.e., the Kalman Filter/Smoother), is often the immedate assumption, there&#39;s nothing mathematically preventing us from assuming othe rnoise </p><h2 id="The-Filtering-Problem"><a class="docs-heading-anchor" href="#The-Filtering-Problem">The Filtering Problem</a><a id="The-Filtering-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Filtering-Problem" title="Permalink"></a></h2><p>In LDS models, one of the three major problems is filtering. Specifically, we are interested in estiamting the latent state <span>$x_t$</span> given the observed data <span>$y_1, \ldots, y_t$</span>. Otherwise stated, we want to solve the following integral:</p><h2 id="The-Smoothing-Problem"><a class="docs-heading-anchor" href="#The-Smoothing-Problem">The Smoothing Problem</a><a id="The-Smoothing-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Smoothing-Problem" title="Permalink"></a></h2><h2 id="The-Prediction-Problem"><a class="docs-heading-anchor" href="#The-Prediction-Problem">The Prediction Problem</a><a id="The-Prediction-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Prediction-Problem" title="Permalink"></a></h2><p>When the state and observation noise are Gaussian, the LDS is a Gaussian LDS, often refered to as the Kalman filter/smoother. This model can be described as follows:</p><p class="math-container">\[\begin{align*}
x_{t+1} &amp;\sim \mathcal{N}(A x_t + b, Q)\\
y_t &amp;\sim \mathcal{N}(C x_t + d, R) 
\end{align*}\]</p><p>where <span>$A$</span> is the state transition matrix, <span>$C$</span> is the observation matrix, <span>$b$</span> and <span>$d$</span> are bias terms, and <span>$Q$</span> and <span>$R$</span> are the state and observation noise covariance matrices, respectively.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianObservationModel" href="#StateSpaceDynamics.GaussianObservationModel"><code>StateSpaceDynamics.GaussianObservationModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianObservationModel{T&lt;:Real} &lt;: AbstractObservationModel</code></pre><p>Represents the observation model of a Linear Dynamical System with Gaussian noise.</p><p><strong>Fields</strong></p><ul><li><code>C::Matrix{T}</code>: Observation matrix</li><li><code>R::Matrix{T}</code>: Observation noise covariance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.GaussianObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.GaussianObservationModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianObservationModel(; C, R, obs_dim, latent_dim)</code></pre><p>Construct a GaussianObservationModel with the given parameters or random initializations.</p><p><strong>Arguments</strong></p><ul><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>R::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation noise covariance</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if C or R is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianStateModel" href="#StateSpaceDynamics.GaussianStateModel"><code>StateSpaceDynamics.GaussianStateModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianStateModel{T&lt;:Real} &lt;: AbstractStateModel</code></pre><p>Represents the state model of a Linear Dynamical System with Gaussian noise.</p><p><strong>Fields</strong></p><ul><li><code>A::Matrix{T}</code>: Transition matrix</li><li><code>Q::Matrix{T}</code>: Process noise covariance</li><li><code>x0::Vector{T}</code>: Initial state</li><li><code>P0::Matrix{T}</code>: Initial state covariance</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianStateModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.GaussianStateModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.GaussianStateModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianStateModel(; A, Q, x0, P0, latent_dim)</code></pre><p>Construct a GaussianStateModel with the given parameters or random initializations.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Transition matrix</li><li><code>Q::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Process noise covariance</li><li><code>x0::Vector{T}=Vector{T}(undef, 0)</code>: Initial state</li><li><code>P0::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Initial state covariance</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if any matrix is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.LinearDynamicalSystem" href="#StateSpaceDynamics.LinearDynamicalSystem"><code>StateSpaceDynamics.LinearDynamicalSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearDynamicalSystem{S&lt;:AbstractStateModel, O&lt;:AbstractObservationModel}</code></pre><p>Represents a unified Linear Dynamical System with customizable state and observation models.</p><p><strong>Fields</strong></p><ul><li><code>state_model::S</code>: The state model (e.g., GaussianStateModel)</li><li><code>obs_model::O</code>: The observation model (e.g., GaussianObservationModel or PoissonObservationModel)</li><li><code>latent_dim::Int</code>: Dimension of the latent state</li><li><code>obs_dim::Int</code>: Dimension of the observations</li><li><code>fit_bool::Vector{Bool}</code>: Vector indicating which parameters to fit during optimization</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonObservationModel" href="#StateSpaceDynamics.PoissonObservationModel"><code>StateSpaceDynamics.PoissonObservationModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonObservationModel{T&lt;:Real} &lt;: AbstractObservationModel</code></pre><p>Represents the observation model of a Linear Dynamical System with Poisson observations.</p><p><strong>Fields</strong></p><ul><li><code>C::Matrix{T}</code>: Observation matrix</li><li><code>log_d::Vector{T}</code>: Mean firing rate vector (log space)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.PoissonObservationModel-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.PoissonObservationModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonObservationModel(; C, log_d, obs_dim, latent_dim)</code></pre><p>Construct a PoissonObservationModel with the given parameters or random initializations.</p><p><strong>Arguments</strong></p><ul><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>log_d::Vector{T}=Vector{T}(undef, 0)</code>: Mean firing rate vector (log space)</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if any matrix is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.GaussianLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.GaussianLDS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianLDS(; A, C, Q, R, x0, P0, fit_bool, obs_dim, latent_dim)</code></pre><p>Construct a Linear Dynamical System with Gaussian state and observation models.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Transition matrix</li><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>Q::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Process noise covariance</li><li><code>R::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation noise covariance</li><li><code>x0::Vector{T}=Vector{T}(undef, 0)</code>: Initial state</li><li><code>P0::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Initial state covariance</li><li><code>fit_bool::Vector{Bool}=fill(true, 6)</code>: Vector indicating which parameters to fit during optimization</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if C or R is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if A, Q, x0, P0, or C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.Gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient(lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}, x::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Compute the gradient of the log-likelihood with respect to the latent states for a linear dynamical system.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li><li><code>y::AbstractMatrix{T}</code>: The observed data.</li><li><code>x::AbstractMatrix{T}</code>: The latent states.</li></ul><p><strong>Returns</strong></p><ul><li><code>grad::Matrix{T}</code>: Gradient of the log-likelihood with respect to the latent states.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.Gradient-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}, Matrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.Gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient(lds::LinearDynamicalSystem{S,O}, y::Matrix{T}, x::Matrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the gradient of the log-likelihood of a Poisson Linear Dynamical System model for a single trial.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>y::Matrix{T}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps)</li><li><code>x::Matrix{T}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>steps)</li></ul><p><strong>Returns</strong></p><ul><li><code>grad::Matrix{T}</code>: The gradient of the log-likelihood. Dimensions: (latent<em>dim, T</em>steps)</li></ul><p><strong>Note</strong></p><p>The gradient is computed with respect to the latent states x. Each row of the returned gradient corresponds to the gradient for a single time step.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.Hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessian(lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}, x::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Construct the Hessian matrix of the log-likelihood of the LDS model given a set of observations.</p><p>This function is used for the direct optimization of the log-likelihood as advocated by Paninski et al. (2009).  The block tridiagonal structure of the Hessian is exploited to reduce the number of parameters that need to be computed, and to reduce the memory requirements. Together with the gradient, this allows for Kalman Smoothing to be performed  by simply solving a linear system of equations:</p><pre><code class="nohighlight hljs">̂xₙ₊₁ = ̂xₙ - H \ ∇</code></pre><p>where ̂xₙ is the current smoothed state estimate, H is the Hessian matrix, and ∇ is the gradient of the log-likelihood.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li><li><code>y::AbstractMatrix{T}</code>: Matrix of observations.</li><li><code>x::AbstractMatrix{T}</code>: Matrix of latent states.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::Matrix{T}</code>: Hessian matrix of the log-likelihood.</li><li><code>H_diag::Vector{Matrix{T}}</code>: Main diagonal blocks of the Hessian.</li><li><code>H_super::Vector{Matrix{T}}</code>: Super-diagonal blocks of the Hessian.</li><li><code>H_sub::Vector{Matrix{T}}</code>: Sub-diagonal blocks of the Hessian.</li></ul><p><strong>Note</strong></p><ul><li><code>x</code> is not used in this function, but is required to match the function signature of other Hessian calculations e.g., in PoissonLDS.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.Hessian-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{T}, AbstractMatrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.Hessian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessian(lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}, x::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the Hessian matrix of the log-likelihood for a Poisson Linear Dynamical System.</p><p>This function computes the Hessian matrix, which represents the second-order partial derivatives of the log-likelihood with respect to the latent states.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System with Poisson observations.</li><li><code>y::AbstractMatrix{T}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps)</li><li><code>x::AbstractMatrix{T}</code>: The current estimate of latent states. Dimensions: (latent<em>dim, T</em>steps)</li></ul><p><strong>Returns</strong></p><ul><li><code>H::Matrix{T}</code>: The full Hessian matrix.</li><li><code>H_diag::Vector{Matrix{T}}</code>: The main diagonal blocks of the Hessian.</li><li><code>H_super::Vector{Matrix{T}}</code>: The super-diagonal blocks of the Hessian.</li><li><code>H_sub::Vector{Matrix{T}}</code>: The sub-diagonal blocks of the Hessian.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real" href="#StateSpaceDynamics.PoissonLDS-Union{Tuple{}, Tuple{T}} where T&lt;:Real"><code>StateSpaceDynamics.PoissonLDS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonLDS(; A, C, Q, log_d, x0, P0, refractory_period, fit_bool, obs_dim, latent_dim)</code></pre><p>Construct a Linear Dynamical System with Gaussian state and Poisson observation models.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Transition matrix</li><li><code>C::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Observation matrix</li><li><code>Q::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Process noise covariance</li><li><code>log_d::Vector{T}=Vector{T}(undef, 0)</code>: Mean firing rate vector (log space)</li><li><code>x0::Vector{T}=Vector{T}(undef, 0)</code>: Initial state</li><li><code>P0::Matrix{T}=Matrix{T}(undef, 0, 0)</code>: Initial state covariance</li><li><code>refractory_period::Int=1</code>: Refractory period</li><li><code>fit_bool::Vector{Bool}=fill(true, 7)</code>: Vector indicating which parameters to fit during optimization</li><li><code>obs_dim::Int</code>: Dimension of the observations (required if C, D, or log_d is not provided.)</li><li><code>latent_dim::Int</code>: Dimension of the latent state (required if A, Q, x0, P0, or C is not provided.)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_function-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractArray{&lt;:Real, 3}, AbstractMatrix{&lt;:Real}}" href="#StateSpaceDynamics.Q_function-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractArray{&lt;:Real, 3}, AbstractMatrix{&lt;:Real}}"><code>StateSpaceDynamics.Q_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q(A, Q, H, R, P0, x0, E_z, E_zz, E_zz_prev, y)</code></pre><p>Calculate the complete Q-function for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{&lt;:Real}</code>: The state transition matrix.</li><li><code>Q::AbstractMatrix{&lt;:Real}</code>: The process noise covariance matrix (or its Cholesky factor).</li><li><code>H::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>R::AbstractMatrix{&lt;:Real}</code>: The observation noise covariance matrix (or its Cholesky factor).</li><li><code>P0::AbstractMatrix{&lt;:Real}</code>: The initial state covariance matrix (or its Cholesky factor).</li><li><code>x0::Vector{&lt;:Real}</code>: The initial state mean.</li><li><code>E_z::Matrix{&lt;:Real}</code>: The expected latent states, size (state_dim, T).</li><li><code>E_zz::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>E_zz_prev::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>y::Matrix{&lt;:Real}</code>: The observed data, size (obs_dim, T).</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_val::Float64</code>: The complete Q-function value.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_function-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Vector{T}, Matrix{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where T&lt;:Real" href="#StateSpaceDynamics.Q_function-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Vector{T}, Matrix{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where T&lt;:Real"><code>StateSpaceDynamics.Q_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_function(A::Matrix{T}, Q::Matrix{T}, C::Matrix{T}, log_d::Vector{T}, x0::Vector{T}, P0::Matrix{T}, E_z::Matrix{T}, E_zz::Array{T, 3}, E_zz_prev::Array{T, 3}, P_smooth::Array{T, 3}, y::Matrix{T})</code></pre><p>Calculate the Q-function for the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}</code>: The transition matrix.</li><li><code>Q::Matrix{T}</code>: The process noise covariance matrix.</li><li><code>C::Matrix{T}</code>: The observation matrix.</li><li><code>log_d::Vector{T}</code>: The mean firing rate vector in log space.</li><li><code>x0::Vector{T}</code>: The initial state mean.</li><li><code>P0::Matrix{T}</code>: The initial state covariance matrix.</li><li><code>E_z::Matrix{T}</code>: The expected latent states.</li><li><code>E_zz::Array{T, 3}</code>: The expected latent states x the latent states.</li><li><code>E_zz_prev::Array{T, 3}</code>: The expected latent states x the previous latent states.</li><li><code>P_smooth::Array{T, 3}</code>: The smoothed state covariances.</li><li><code>y::Matrix{T}</code>: The observed data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Q-function for the Linear Dynamical System.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_obs-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractMatrix{&lt;:Real}}" href="#StateSpaceDynamics.Q_obs-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractMatrix{&lt;:Real}}"><code>StateSpaceDynamics.Q_obs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_obs(H, R, E_z, E_zz, y)</code></pre><p>Calculate the observation component of the Q-function for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>H::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>R::AbstractMatrix{&lt;:Real}</code>: The observation noise covariance matrix (or its Cholesky factor).</li><li><code>E_z::Matrix{&lt;:Real}</code>: The expected latent states, size (state_dim, T).</li><li><code>E_zz::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>y::Matrix{&lt;:Real}</code>: The observed data, size (obs_dim, T).</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_val::Float64</code>: The observation component of the Q-function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_observation_model-Union{Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractArray{U, 3}, AbstractArray{U, 4}, Array{U, 3}}} where {T&lt;:Real, U&lt;:Real}" href="#StateSpaceDynamics.Q_observation_model-Union{Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractArray{U, 3}, AbstractArray{U, 4}, Array{U, 3}}} where {T&lt;:Real, U&lt;:Real}"><code>StateSpaceDynamics.Q_observation_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_observation_model(C::Matrix{&lt;:Real}, D::Matrix{&lt;:Real}, log_d::Vector{&lt;:Real}, E_z::Array{&lt;:Real}, E_zz::Array{&lt;:Real}, y::Array{&lt;:Real})</code></pre><p>Calculate the Q-function for the observation model.</p><p><strong>Arguments</strong></p><ul><li><code>C::Matrix{&lt;:Real}</code>: The observation matrix.</li><li><code>log_d::Vector{&lt;:Real}</code>: The mean firing rate vector in log space.</li><li><code>E_z::Array{&lt;:Real}</code>: The expected latent states.</li><li><code>E_zz::Array{&lt;:Real}</code>: The expected latent states x the latent states.</li><li><code>y::Array{&lt;:Real}</code>: The observed data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Q-function for the observation model.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_state-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractArray{&lt;:Real, 3}}" href="#StateSpaceDynamics.Q_state-Tuple{AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}, AbstractArray{&lt;:Real, 3}, AbstractArray{&lt;:Real, 3}}"><code>StateSpaceDynamics.Q_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_state(A, Q, P0, x0, E_z, E_zz, E_zz_prev)</code></pre><p>Calculate the state component of the Q-function for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{&lt;:Real}</code>: The state transition matrix.</li><li><code>Q::AbstractMatrix{&lt;:Real}</code>: The process noise covariance matrix (or its Cholesky factor).</li><li><code>P0::AbstractMatrix{&lt;:Real}</code>: The initial state covariance matrix (or its Cholesky factor).</li><li><code>x0::Vector{&lt;:Real}</code>: The initial state mean.</li><li><code>E_z::Matrix{&lt;:Real}</code>: The expected latent states, size (state_dim, T).</li><li><code>E_zz::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T).</li><li><code>E_zz_prev::Array{&lt;:Real, 3}</code>: The expected value of z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T).</li></ul><p><strong>Returns</strong></p><ul><li><code>Q_val::Float64</code>: The state component of the Q-function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.Q_state-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real" href="#StateSpaceDynamics.Q_state-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}, Vector{T}, Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real"><code>StateSpaceDynamics.Q_state</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Q_state(A::Matrix{T}, Q::Matrix{T}, P0::Matrix{T}, x0::Vector{T}, E_z::Array{T, 3}, E_zz::Array{T, 4}, E_zz_prev::Array{T, 4}) where T&lt;:Real</code></pre><p>Calculates the Q-function for the state model over multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}</code>: The transition matrix.</li><li><code>Q::Matrix{T}</code>: The process noise covariance matrix.</li><li><code>P0::Matrix{T}</code>: The initial state covariance matrix.</li><li><code>x0::Vector{T}</code>: The initial state mean.</li><li><code>E_z::Array{T, 3}</code>: The expected latent states.</li><li><code>E_zz::Array{T, 4}</code>: The expected latent states x the latent states.</li><li><code>E_zz_prev::Array{T, 4}</code>: The expected latent states x the previous latent states.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Q-function for the state model.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.calculate_elbo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_elbo(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, E_zz_prev::Array{T,4}, p_smooth::Array{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Calculate the Evidence Lower Bound (ELBO) for a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Returns</strong></p><ul><li><code>elbo::T</code>: The Evidence Lower Bound (ELBO) for the LDS.</li></ul><p><strong>Note</strong></p><ul><li>For a GaussianLDS the ELBO is equivalent to the total marginal likelihood</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.calculate_elbo-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}, Float64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.calculate_elbo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_elbo(plds::LinearDynamicalSystem{S,O}, E_z::Array{T, 3}, E_zz::Array{T, 4}, 
               E_zz_prev::Array{T, 4}, P_smooth::Array{T, 4}, y::Array{T, 3}) where 
               {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the Evidence Lower Bound (ELBO) for a Poisson Linear Dynamical System (PLDS).</p><p><strong>Arguments</strong></p><ul><li><code>plds::LinearDynamicalSystem{S,O}</code>: The PLDS model.</li><li><code>E_z::Array{T, 3}</code>: Expected values of latent states. Dimensions: (state<em>dim, t</em>steps, n_trials).</li><li><code>E_zz::Array{T, 4}</code>: Expected values of latent state outer products. Dimensions: (state<em>dim, state</em>dim, t<em>steps, n</em>trials).</li><li><code>E_zz_prev::Array{T, 4}</code>: Expected values of latent state outer products with previous time step. Dimensions: (state dimension, state dimension, t<em>steps-1, n</em>trials).</li><li><code>P_smooth::Array{T, 4}</code>: Smoothed covariance matrices. Dimensions: (state dimension, state dimension, t<em>steps, n</em>trials).</li><li><code>y::Array{T, 3}</code>: Observed data. Dimensions: (obs<em>dim, t</em>steps, n_trials).</li></ul><p><strong>Returns</strong></p><ul><li><code>elbo::Float64</code>: The calculated Evidence Lower Bound.</li></ul><p><strong>Description</strong></p><p>This function computes the ELBO for a PLDS model, which consists of two main components:</p><ol><li>The expected complete log-likelihood (ECLL), calculated using the Q_function.</li><li>The entropy of the variational distribution, calculated using gaussian entropy.</li></ol><p>The ELBO is then computed as: ELBO = ECLL - Entropy.</p><p><strong>Note</strong></p><p>Ensure that the dimensions of input arrays match the expected dimensions as described in the arguments section.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.estep-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.estep-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.estep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estep(lds::LinearDynamicalSystem{S,O}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Perform the E-step of the EM algorithm for a Linear Dynamical System, treating all input as multi-trial.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n<em>trials)   Note: For single-trial data, use y[1:1, :, :] to create a 3D array with n</em>trials = 1</li></ul><p><strong>Returns</strong></p><ul><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>x_smooth::Array{T,3}</code>: Smoothed state estimates, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>ml::T</code>: Total marginal likelihood (log-likelihood) of the data across all trials</li></ul><p><strong>Note</strong></p><ul><li>This function first smooths the data using the <code>smooth</code> function, then computes sufficient statistics.</li><li>It treats all input as multi-trial, with single-trial being a special case where n_trials = 1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.fit!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.fit!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.fit!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit!(lds::LinearDynamicalSystem{S,O}, y::Matrix{T}; 
     max_iter::Int=1000, 
     tol::Real=1e-12, 
     ) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Fit a Linear Dynamical System using the Expectation-Maximization (EM) algorithm with Kalman smoothing.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System to be fitted.</li><li><code>y::Matrix{T}</code>: Observed data, size (obs<em>dim, T</em>steps).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>max_iter::Int=1000</code>: Maximum number of EM iterations.</li><li><code>tol::Real=1e-12</code>: Convergence tolerance for log-likelihood change.</li></ul><p><strong>Returns</strong></p><ul><li><code>mls::Vector{T}</code>: Vector of log-likelihood values for each iteration.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.gradient_observation_model!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractArray{T}, AbstractArray{T}, Array{T}}} where T&lt;:Real" href="#StateSpaceDynamics.gradient_observation_model!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractArray{T}, AbstractArray{T}, Array{T}}} where T&lt;:Real"><code>StateSpaceDynamics.gradient_observation_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gradient_observation_model!(grad::AbstractVector{T}, C::AbstractMatrix{T}, log_d::AbstractVector{T}, E_z::AbstractArray{T}, P_smooth::AbstractArray{T}, y::Array{T}) where T&lt;:Real</code></pre><p>Compute the gradient of the Q-function with respect to the observation model parameters (C and log_d) for a Poisson Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>grad::AbstractVector{T}</code>: Pre-allocated vector to store the computed gradient.</li><li><code>C::AbstractMatrix{T}</code>: The observation matrix. Dimensions: (obs<em>dim, latent</em>dim)</li><li><code>log_d::AbstractVector{T}</code>: The log of the baseline firing rates. Dimensions: (obs_dim,)</li><li><code>E_z::AbstractArray{T}</code>: The expected latent states. Dimensions: (latent<em>dim, t</em>steps, n_trials)</li><li><code>P_smooth::AbstractArray{T}</code>: The smoothed state covariances. Dimensions: (latent<em>dim, latent</em>dim, t<em>steps, n</em>trials)</li><li><code>y::Array{T}</code>: The observed data. Dimensions: (obs<em>dim, t</em>steps, N-trials)</li></ul><p><strong>Note</strong></p><p>This function modifies <code>grad</code> in-place. The gradient is computed for the negative Q-function, as we&#39;re minimizing -Q in optimization routines.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Array{T, 3}, StateSpaceDynamics.LinearDynamicalSystem{O, S}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{Array{T, 3}, StateSpaceDynamics.LinearDynamicalSystem{O, S}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikelihood(x::Array{T, 3}, lds::LinearDynamicalSystem{S,O}, y::Array{T, 3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Calculate the complete-data log-likelihood of a Poisson Linear Dynamical System model for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>x::Array{T, 3}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>y::Array{T, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Returns</strong></p><ul><li><code>ll::T</code>: The log-likelihood value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lds = PoissonLDS(obs_dim=4, latent_dim=3)
x, y = sample(lds, 100, 10)  # 10 trials, 100 time steps each
ll = loglikelihood(x, lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{U}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.PoissonObservationModel)}" href="#StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{U}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.PoissonObservationModel)}"><code>StateSpaceDynamics.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikelihood(x::Matrix{T}, lds::LinearDynamicalSystem{S,O}, y::Matrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel, O&lt;:PoissonObservationModel}</code></pre><p>Calculate the complete-data log-likelihood of a Poisson Linear Dynamical System model for a single trial. </p><p><strong>Arguments</strong></p><ul><li><code>x::Matrix{T}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>steps)</li><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>y::Matrix{T}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps)</li></ul><p><strong>Returns</strong></p><ul><li><code>ll::T</code>: The log-likelihood value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-juliaestep hljs">lds = PoissonLDS(obs_dim=4, latent_dim=3)
x, y = sample(lds, 100, 1)  # 1 trial, 100 time steps
ll = loglikelihood(x, lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}} where {T&lt;:Real, U&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.GaussianObservationModel)}" href="#StateSpaceDynamics.loglikelihood-Union{Tuple{O}, Tuple{S}, Tuple{U}, Tuple{T}, Tuple{AbstractMatrix{T}, StateSpaceDynamics.LinearDynamicalSystem{S, O}, AbstractMatrix{U}}} where {T&lt;:Real, U&lt;:Real, S&lt;:(StateSpaceDynamics.GaussianStateModel), O&lt;:(StateSpaceDynamics.GaussianObservationModel)}"><code>StateSpaceDynamics.loglikelihood</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loglikelihood(x::AbstractMatrix{T}, lds::LinearDynamicalSystem{S,O}, y::AbstractMatrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Calculate the complete-data log-likelihood of a linear dynamical system (LDS) given the observed data.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: The state sequence of the LDS.</li><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li><li><code>y::AbstractMatrix{T}</code>: The observed data.</li></ul><p><strong>Returns</strong></p><ul><li><code>ll::T</code>: The complete-data log-likelihood of the LDS.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.mstep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mstep!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, E_zz_prev::Array{T,4}, p_smooth::Array{T, 4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Perform the M-step of the EM algorithm for a Linear Dynamical System with multi-trial data.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials) (not used)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place by updating all model parameters.</li><li>Updates are performed only for parameters where the corresponding <code>fit_bool</code> is true.</li><li>All update functions now handle multi-trial data.</li><li>P_smooth is required but not used in the M-step so that the function signature matches the PoissonLDS version.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.mstep!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 4}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.mstep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mstep!(plds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, E_zz_Prev{T,4}, p_smooth{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Perform the M-step of the EM algorithm for a Poisson Linear Dynamical System with multi-trial data.</p><p><strong>Arguments</strong></p><ul><li><code>plds::LinearDynamicalSystem{S,O}</code>: The Poisson Linear Dynamical System struct.</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>plds</code> in-place by updating all model parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.obsparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}" href="#StateSpaceDynamics.obsparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}"><code>StateSpaceDynamics.obsparams</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obsparams(lds::LinearDynamicalSystem{S,O}) where {S&lt;:AbstractStateModel,O&lt;:AbstractObservationModel}</code></pre><p>Extract the observation parameters from a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li></ul><p><strong>Returns</strong></p><ul><li><code>params::Vector{Vector{Real}}</code>: Vector of observation parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(lds::LinearDynamicalSystem{S,O}, T_steps::Int, n_trials::Int) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Sample from a Linear Dynamical System (LDS) model for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>T_steps::Int</code>: The number of time steps to sample for each trial.</li><li><code>n_trials::Int</code>: The number of trials to sample.=</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{T, 3}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>y::Array{T, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lds = GaussianLDS(obs_dim=4, latent_dim=3)
x, y = sample(lds, 10, 100)  # 10 trials, 100 time steps each</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.sample-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Int64, Int64}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(lds::LinearDynamicalSystem{S,O}, T_steps::Int, n_trials::Int) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Sample from a Poisson Linear Dynamical System (LDS) model for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System model.</li><li><code>T_steps::Int</code>: The number of time steps to sample for each trial.</li><li><code>n_trials::Int</code>: The number of trials to sample.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{T, 3}</code>: The latent state variables. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>y::Array{Int, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">lds = LinearDynamicalSystem(obs_dim=4, latent_dim=3)
x, y = sample(lds, 100, 10)  # 10 trials, 100 time steps each</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.smooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(lds::LinearDynamicalSystem{S,O}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>This function performs direct smoothing for a linear dynamical system (LDS) given the system parameters and the observed data for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The LDS object representing the system parameters.</li><li><code>y::Array{T,3}</code>: The observed data array with dimensions (obs<em>dim, tiem</em>steps, n_trials).</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Array{T,3}</code>: The optimal state estimates with dimensions (n<em>trials, time</em>steps, latent_dim).</li><li><code>p_smooth::Array{T,4}</code>: The posterior covariance matrices with dimensions (latent<em>dim, latent</em>dim, time<em>steps, n</em>trials).</li><li><code>inverse_offdiag::Array{T,4}</code>: The inverse off-diagonal matrices with dimensions (latent<em>dim, latent</em>dim, time<em>steps, n</em>trials).</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lds = GaussianLDS(obs_dim=4, latent_dim=3)
y = randn(5, 100, 4)  # 5 trials, 100 time steps, 4 observed dimension
x, p_smooth, inverse_offdiag = smooth(lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.smooth-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Matrix{T}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.smooth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(lds::LinearDynamicalSystem{S,O}, y::Matrix{T}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>This function performs direct smoothing for a linear dynamical system (LDS) given the system parameters and the observed data.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The LDS object representing the system parameters.</li><li><code>y::Matrix{T}</code>: The observed data matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Matrix{T}</code>: The optimal state estimate.</li><li><code>p_smooth::Array{T, 3}</code>: The posterior covariance matrix.</li><li><code>inverse_offdiag::Array{T, 3}</code>: The inverse off-diagonal matrix.</li><li><code>Q_val::T</code>: The Q-function value.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">lds = GaussianLDS(obs_dim=4, latent_dim=3)
y = randn(100, 4)  # 100 time steps, 4 observed dimensions
x, p_smooth, inverse_offdiag, Q_val = DirectSmoother(lds, y)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.stateparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}" href="#StateSpaceDynamics.stateparams-Union{Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}}, Tuple{O}, Tuple{S}} where {S&lt;:StateSpaceDynamics.AbstractStateModel, O&lt;:StateSpaceDynamics.AbstractObservationModel}"><code>StateSpaceDynamics.stateparams</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stateparams(lds::LinearDynamicalSystem{S,O}) where {S&lt;:AbstractStateModel,O&lt;:AbstractObservationModel}</code></pre><p>Extract the state parameters from a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System.</li></ul><p><strong>Returns</strong></p><ul><li><code>params::Vector{Vector{Real}}</code>: Vector of state parameters.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.sufficient_statistics-Union{Tuple{T}, Tuple{Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real" href="#StateSpaceDynamics.sufficient_statistics-Union{Tuple{T}, Tuple{Array{T, 3}, Array{T, 4}, Array{T, 4}}} where T&lt;:Real"><code>StateSpaceDynamics.sufficient_statistics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sufficient_statistics(x_smooth::Array{T,3}, p_smooth::Array{T,4}, p_smooth_t1::Array{T,4}) where T &lt;: Real</code></pre><p>Compute sufficient statistics for the EM algorithm in a Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>x_smooth::Array{T,3}</code>: Smoothed state estimates, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>p_smooth::Array{T,4}</code>: Smoothed state covariances, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>p_smooth_t1::Array{T,4}</code>: Lag-one covariance smoother, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li></ul><p><strong>Returns</strong></p><ul><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li><li><code>E_zz_prev::Array{T,4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li></ul><p><strong>Note</strong></p><ul><li>The function computes the expected values for all trials.</li><li>For single-trial data, use inputs with n_trials = 1.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_C!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.update_C!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.update_C!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_C!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Update the observation matrix C of the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[5]</code> is true.</li><li>The result is averaged across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_Q!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 4}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.update_Q!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 4}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.update_Q!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_Q!(lds::LinearDynamicalSystem{S,O}, E_zz::Array{T, 4}, E_zz_prev::Array{T, 4}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Update the process noise covariance matrix Q of the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_zz::Array{T, 4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz_prev::Array{T, 4}</code>: Expected z<em>t * z</em>{t-1}&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[4]</code> is true.</li><li>The result is averaged across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_R!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}" href="#StateSpaceDynamics.update_R!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.GaussianObservationModel{T}}"><code>StateSpaceDynamics.update_R!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_R!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}, y::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Update the observation noise covariance matrix R of the Linear Dynamical System.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>y::Array{T,3}</code>: Observed data, size (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[6]</code> is true.</li><li>The result is averaged across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_initial_state_covariance!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.update_initial_state_covariance!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.update_initial_state_covariance!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_initial_state_covariance!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}, E_zz::Array{T,4}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Update the initial state covariance of the Linear Dynamical System using the average across all trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li><li><code>E_zz::Array{T,4}</code>: Expected z<em>t * z</em>t&#39;, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials, state_dim)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[2]</code> is true.</li><li>The initial state covariance is computed as the average of the first time step across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_initial_state_mean!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}" href="#StateSpaceDynamics.update_initial_state_mean!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.AbstractObservationModel{T}}"><code>StateSpaceDynamics.update_initial_state_mean!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_initial_state_mean!(lds::LinearDynamicalSystem{S,O}, E_z::Array{T,3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Update the initial state mean of the Linear Dynamical System using the average across all trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{S,O}</code>: The Linear Dynamical System struct</li><li><code>E_z::Array{T,3}</code>: Expected latent states, size (state<em>dim, state</em>dim, T<em>steps, n</em>trials)</li></ul><p><strong>Note</strong></p><ul><li>This function modifies <code>lds</code> in-place.</li><li>The update is only performed if <code>lds.fit_bool[1]</code> is true.</li><li>The initial state mean is computed as the average of the first time step across all trials.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.update_observation_model!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}" href="#StateSpaceDynamics.update_observation_model!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{StateSpaceDynamics.LinearDynamicalSystem{S, O}, Array{T, 3}, Array{T, 4}, Array{T, 3}}} where {T&lt;:Real, S&lt;:StateSpaceDynamics.GaussianStateModel{T}, O&lt;:StateSpaceDynamics.PoissonObservationModel{T}}"><code>StateSpaceDynamics.update_observation_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_observation_model!(plds::LinearDynamicalSystem{S,O}, E_z::Array{T, 3}, P_smooth::Array{T, 4}, y::Array{T, 3}) where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:PoissonObservationModel{T}}</code></pre><p>Update the observation model parameters of a Poisson Linear Dynamical System using gradient-based optimization.</p><p><strong>Arguments</strong></p><ul><li><code>plds::LinearDynamicalSystem{S,O}</code>: The Poisson Linear Dynamical System model.</li><li><code>E_z::Array{T, 3}</code>: The expected latent states. Dimensions: (latent<em>dim, T</em>Steps, n_trials)</li><li><code>P_smooth::Array{T, 4}</code>: The smoothed state covariances. Dimensions: (latent<em>dim, T</em>Steps, n<em>trials, latent</em>dim)</li><li><code>y::Array{T, 3}</code>: The observed data. Dimensions: (obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Note</strong></p><p>This function modifies <code>plds</code> in-place by updating the observation model parameters (C and log<em>d). The optimization is performed only if `plds.fit</em>bool[5]` is true.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../HiddenMarkovModels/">Hidden Markov Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 3 March 2025 18:31">Monday 3 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
