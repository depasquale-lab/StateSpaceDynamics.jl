<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Dynamical Systems · StateSpaceDynamics.jl</title><meta name="title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta property="og:title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta property="twitter:title" content="Linear Dynamical Systems · StateSpaceDynamics.jl"/><meta name="description" content="Documentation for StateSpaceDynamics.jl."/><meta property="og:description" content="Documentation for StateSpaceDynamics.jl."/><meta property="twitter:description" content="Documentation for StateSpaceDynamics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="StateSpaceDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">StateSpaceDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Models</span><ul><li class="is-active"><a class="tocitem" href>Linear Dynamical Systems</a><ul class="internal"><li><a class="tocitem" href="#The-Gaussian-Linear-Dynamical-System"><span>The Gaussian Linear Dynamical System</span></a></li><li><a class="tocitem" href="#The-Poisson-Linear-Dynamical-System"><span>The Poisson Linear Dynamical System</span></a></li><li><a class="tocitem" href="#Sampling-from-Linear-Dynamical-Systems"><span>Sampling from Linear Dynamical Systems</span></a></li><li><a class="tocitem" href="#Inference-in-Linear-Dynamical-Systems"><span>Inference in Linear Dynamical Systems</span></a></li><li><a class="tocitem" href="#Newton&#39;s-Method-for-Latent-State-Optimization"><span>Newton&#39;s Method for Latent State Optimization</span></a></li><li><a class="tocitem" href="#Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models"><span>Laplace Approximation of Posterior for Non-Conjugate Observation Models</span></a></li><li><a class="tocitem" href="#Learning-in-Linear-Dynamical-Systems"><span>Learning in Linear Dynamical Systems</span></a></li></ul></li><li><a class="tocitem" href="../HiddenMarkovModels/">Hidden Markov Models</a></li><li><a class="tocitem" href="../SLDS/">Switching Linear Dynamical Systems</a></li><li><a class="tocitem" href="../EmissionModels/">EmissionModels</a></li><li><a class="tocitem" href="../MixtureModels/">Mixture Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/gaussian_latent_dynamics_example/">Gaussian LDS Example</a></li><li><a class="tocitem" href="../tutorials/poisson_latent_dynamics_example/">Poisson LDS Example</a></li><li><a class="tocitem" href="../tutorials/hidden_markov_model_example/">Hidden Markov Model Example</a></li><li><a class="tocitem" href="../tutorials/gaussian_glm_hmm_example/">Gaussian GLM-GMM Example</a></li><li><a class="tocitem" href="../tutorials/gaussian_mixture_model_example/">Gaussian Mixture Model Example</a></li><li><a class="tocitem" href="../tutorials/poisson_mixture_model_example/">Poisson Mixture Model Example</a></li></ul></li><li><a class="tocitem" href="../Misc/">Miscellaneous</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Models</a></li><li class="is-active"><a href>Linear Dynamical Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Dynamical Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/main/docs/src/LinearDynamicalSystems.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="What-is-a-Linear-Dynamical-System?"><a class="docs-heading-anchor" href="#What-is-a-Linear-Dynamical-System?">What is a Linear Dynamical System?</a><a id="What-is-a-Linear-Dynamical-System?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-a-Linear-Dynamical-System?" title="Permalink"></a></h1><p>A <strong>Linear Dynamical System (LDS)</strong> is a mathematical model used to describe how a system evolves over time. These systems are a subset of <strong>state-space models</strong>, where the hidden state dynamics are continuous. What makes these models <em>linear</em> is that the latent dynamics evolve according to a linear function of the previous state. The observations, however, can be related to the hidden state through a nonlinear link function.</p><p>At its core, an LDS defines:</p><ul><li><strong>A state transition function</strong>: how the internal state evolves from one time step to the next.</li><li><strong>An observation function</strong>: how the internal state generates the observed data.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.LinearDynamicalSystem" href="#StateSpaceDynamics.LinearDynamicalSystem"><code>StateSpaceDynamics.LinearDynamicalSystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearDynamicalSystem{T&lt;:Real, S&lt;:AbstractStateModel{T}, O&lt;:AbstractObservationModel{T}}</code></pre><p>Represents a unified Linear Dynamical System with customizable state and observation models.</p><p><strong>Fields</strong></p><ul><li><code>state_model::S</code>: The state model (e.g., GaussianStateModel)</li><li><code>obs_model::O</code>: The observation model (e.g., GaussianObservationModel or PoissonObservationModel)</li><li><code>latent_dim::Int</code>: Dimension of the latent state</li><li><code>obs_dim::Int</code>: Dimension of the observations</li><li><code>fit_bool::Vector{Bool}</code>: Vector indicating which parameters to fit during optimization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L49-L60">source</a></section></article><h2 id="The-Gaussian-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#The-Gaussian-Linear-Dynamical-System">The Gaussian Linear Dynamical System</a><a id="The-Gaussian-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#The-Gaussian-Linear-Dynamical-System" title="Permalink"></a></h2><p>The <strong>Gaussian Linear Dynamical System</strong> — typically just referred to as an LDS — is a specific type of linear dynamical system where both the state transition and observation functions are linear, and all noise is Gaussian.</p><p>The generative model is given by:</p><p class="math-container">\[\begin{aligned}
    x_t &amp;\sim \mathcal{N}(A x_{t-1}, Q) \\
    y_t &amp;\sim \mathcal{N}(C x_t, R)
\end{aligned}\]</p><p>Where:</p><ul><li><code>x_t</code> is the hidden state at time <code>t</code></li><li><code>y_t</code> is the observed data at time <code>t</code>  </li><li><code>A</code> is the state transition matrix</li><li><code>C</code> is the observation matrix</li><li><code>Q</code> is the process noise covariance</li><li><code>R</code> is the observation noise covariance</li></ul><p>This can equivalently be written in equation form:</p><p class="math-container">\[\begin{aligned}
    x_t &amp;= A x_{t-1} + \epsilon_t \\
    y_t &amp;= C x_t + \eta_t
\end{aligned}\]</p><p>Where:</p><ul><li><code>ε_t ~ N(0, Q)</code> is the process noise</li><li><code>η_t ~ N(0, R)</code> is the observation noise</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianStateModel" href="#StateSpaceDynamics.GaussianStateModel"><code>StateSpaceDynamics.GaussianStateModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianStateModel{T&lt;:Real. M&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}}</code></pre><p>Represents the state model of a Linear Dynamical System with Gaussian noise.</p><p><strong>Fields</strong></p><ul><li><code>A::M</code>: Transition matrix (size <code>latent_dim×latent_dim</code>). </li><li><code>Q::M</code>: Process noise covariance matrix </li><li><code>x0::V</code>: Initial state vector (length <code>latent_dim</code>).</li><li><code>P0::M</code>: Initial state covariance matrix (size `latent<em>dim×latent</em>dim</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.GaussianObservationModel" href="#StateSpaceDynamics.GaussianObservationModel"><code>StateSpaceDynamics.GaussianObservationModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianObservationModel{T&lt;:Real, M&lt;:AbstractMatrix{T}}</code></pre><p>Represents the observation model of a Linear Dynamical System with Gaussian noise.</p><p><strong>Fields</strong></p><ul><li><code>C::M</code>: Observation matrix of size <code>(obs_dim × latent_dim)</code>. Maps latent states into observation space. </li><li><code>R::M</code>: Observation noise covariance of size <code>(obs_dim × obs_dim)</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L21-L29">source</a></section></article><h2 id="The-Poisson-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#The-Poisson-Linear-Dynamical-System">The Poisson Linear Dynamical System</a><a id="The-Poisson-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#The-Poisson-Linear-Dynamical-System" title="Permalink"></a></h2><p>The <strong>Poisson Linear Dynamical System</strong> is a variant of the LDS where the observations are modeled as counts. This is useful in fields like neuroscience where we are often interested in modeling spike count data. To relate the spiking data to the Gaussian latent variable, we use a nonlinear link function, specifically the exponential function. </p><p>The generative model is given by: </p><p class="math-container">\[\begin{aligned}
    x_t &amp;\sim \mathcal{N}(A x_{t-1}, Q) \\
    y_t &amp;\sim \text{Poisson}(\exp(Cx_t + b))
\end{aligned}\]</p><p>Where <code>b</code> is a bias term.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.PoissonObservationModel" href="#StateSpaceDynamics.PoissonObservationModel"><code>StateSpaceDynamics.PoissonObservationModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoissonObservationModel{T&lt;:Real, M&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}} &lt;: AbstractObservationModel{T}</code></pre><p>Represents the observation model of a Linear Dynamical System with Poisson observations.</p><p><strong>Fields</strong></p><ul><li><code>C::AbstractMatrix{T}</code>: Observation matrix of size <code>(obs_dim × latent_dim)</code>. Maps latent states into observation space.</li><li><code>log_d::AbstractVector{T}</code>: Mean firing rate vector (log space) of size <code>(obs_dim × obs_dim)</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L35-L43">source</a></section></article><h2 id="Sampling-from-Linear-Dynamical-Systems"><a class="docs-heading-anchor" href="#Sampling-from-Linear-Dynamical-Systems">Sampling from Linear Dynamical Systems</a><a id="Sampling-from-Linear-Dynamical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-from-Linear-Dynamical-Systems" title="Permalink"></a></h2><p>You can generate synthetic data from fitted LDS models:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{LinearDynamicalSystem}" href="#Base.rand-Tuple{LinearDynamicalSystem}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Random.rand(lds::LinearDynamicalSystem; tsteps::Int, ntrials::Int)
Random.rand(rng::AbstractRNG, lds::LinearDynamicalSystem; tsteps::Int, ntrials::Int)</code></pre><p>Sample from a Linear Dynamical System.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L167-L172">source</a></section></article><h2 id="Inference-in-Linear-Dynamical-Systems"><a class="docs-heading-anchor" href="#Inference-in-Linear-Dynamical-Systems">Inference in Linear Dynamical Systems</a><a id="Inference-in-Linear-Dynamical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Inference-in-Linear-Dynamical-Systems" title="Permalink"></a></h2><p>In StateSpaceDynamics.jl, we directly maximize the complete-data log-likelihood function with respect to the latent states given the data and the parameters of the model. In other words, the <strong>maximum a priori</strong> (MAP) estimate of the latent state path is:</p><p class="math-container">\[\underset{x}{\text{argmax}}  \left[ \log p(x_0) + \sum_{t=2}^T \log p(x_t \mid x_{t-1}) + \sum_{t=1}^T \log p(y_t \mid x_t) \right]\]</p><p>This MAP estimation approach has the same computational complexity as traditional Kalman filtering and smoothing — <span>$\mathcal{O}(T)$</span> — but is significantly more flexible. Notably, it can handle <strong>nonlinear observations</strong> and <strong>non-Gaussian noise</strong> while still yielding <strong>exact MAP estimates</strong>, unlike approximate techniques such as the Extended Kalman Filter (EKF) or Unscented Kalman Filter (UKF).</p><h2 id="Newton&#39;s-Method-for-Latent-State-Optimization"><a class="docs-heading-anchor" href="#Newton&#39;s-Method-for-Latent-State-Optimization">Newton&#39;s Method for Latent State Optimization</a><a id="Newton&#39;s-Method-for-Latent-State-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Newton&#39;s-Method-for-Latent-State-Optimization" title="Permalink"></a></h2><p>To find the MAP trajectory, we iteratively optimize the latent states using Newton&#39;s method. The update equation at each iteration is:</p><p class="math-container">\[x^{(i+1)} = x^{(i)} - \left[ \nabla^2 \mathcal{L}(x^{(i)}) \right]^{-1} \nabla \mathcal{L}(x^{(i)})\]</p><p>Where:</p><ul><li><span>$\mathcal{L}(x)$</span> is the complete-data log-likelihood:</li></ul><p class="math-container">\[\mathcal{L}(x) = \log p(x_0) + \sum_{t=2}^T \log p(x_t \mid x_{t-1}) + \sum_{t=1}^T \log p(y_t \mid x_t)\]</p><ul><li><span>$\nabla \mathcal{L}(x)$</span> is the gradient of the full log-likelihood with respect to all latent states</li><li><span>$\nabla^2 \mathcal{L}(x)$</span> is the Hessian of the full log-likelihood</li></ul><p>This update is performed over the entire latent state sequence <span>$x_{1:T}$</span>, and repeated until convergence.</p><p>For <strong>Gaussian models</strong>, <span>$\mathcal{L}(x)$</span> is quadratic and Newton&#39;s method converges in a single step — recovering the exact Kalman smoother solution. For <strong>non-Gaussian models</strong>, the Hessian is not constant and the optimization is more complex. However, the MAP estimate can still be computed efficiently using the same approach as the optimization problem is still convex.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.smooth" href="#StateSpaceDynamics.smooth"><code>StateSpaceDynamics.smooth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">smooth(lds, y)</code></pre><p>This function performs direct smoothing for a linear dynamical system (LDS) given the system parameters and the observed data for a single trial</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{T,S,O}</code>: The LDS object representing the system parameters.</li><li><code>y::AbstractMatrix{T}</code>: The observed data matrix.</li><li><code>w::Union{Nothing,AbstractVector{T}}</code>: coeffcients to weight the data.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::AbstractMatrix{T}</code>: The optimal state estimate.</li><li><code>p_smooth::Array{T, 3}</code>: The posterior covariance matrix.</li><li><code>inverse_offdiag::Array{T, 3}</code>: The inverse off-diagonal matrix.</li><li><code>Q_val::T</code>: The Q-function value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L367-L382">source</a></section><section><div><pre><code class="language-julia hljs">smooth(lds, y)</code></pre><p>This function performs direct smoothing for a linear dynamical system (LDS) given the system parameters and the observed data for multiple trials.</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{T,S,O}</code>: The LDS object representing the system parameters.</li><li><code>y::AbstractArray{T,3}</code>: The observed data array with dimensions (obs_dim, tsteps, ntrials).</li></ul><p><strong>Returns</strong></p><ul><li><code>x::AbstractArray{T,3}</code>: The optimal state estimates with dimensions (ntrials, tsteps, latent_dim).</li><li><code>p_smooth::AbstractArray{T,4}</code>: The posterior covariance matrices with dimensions (latent<em>dim, latent</em>dim, tsteps, ntrials).</li><li><code>inverse_offdiag::AbstractArray{T,4}</code>: The inverse off-diagonal matrices with dimensions (latent<em>dim, latent</em>dim, tsteps, ntrials).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L463-L476">source</a></section></article><h2 id="Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models"><a class="docs-heading-anchor" href="#Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models">Laplace Approximation of Posterior for Non-Conjugate Observation Models</a><a id="Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Laplace-Approximation-of-Posterior-for-Non-Conjugate-Observation-Models" title="Permalink"></a></h2><p>In the case of non-Gaussian observations, we can use a Laplace approximation to compute the posterior distribution of the latent states. For Gaussian observations (which are conjugate with the Gaussian state model), the posterior is also Gaussian and is the exact posterior. However, for non-Gaussian observations, we can approximate the posterior using a Gaussian distribution centered at the MAP estimate of the latent states. This approximation is given by:</p><p class="math-container">\[p(x \mid y) \approx \mathcal{N}(x^{*}, -\left[ \nabla^2 \mathcal{L}(x^{*}) \right]^{-1})\]</p><p>Where:</p><ul><li><span>$x^{*}$</span> is the MAP estimate of the latent states</li><li><span>$\nabla^2 \mathcal{L}(x^{*})$</span> is the Hessian of the log-likelihood at the MAP estimate</li></ul><p>Despite the requirement of inverting a Hessian of dimension <span>$(d \times T) \times (d \times T)$</span>, this is still computationally efficient, as the Markov structure of the model renders the Hessian block-tridiagonal, and thus the inversion is tractable.</p><h2 id="Learning-in-Linear-Dynamical-Systems"><a class="docs-heading-anchor" href="#Learning-in-Linear-Dynamical-Systems">Learning in Linear Dynamical Systems</a><a id="Learning-in-Linear-Dynamical-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Learning-in-Linear-Dynamical-Systems" title="Permalink"></a></h2><p>Given the latent structure of state-space models, we must rely on either the Expectation-Maximization (EM) or Variational Inference (VI) approaches to learn the parameters of the model. StateSpaceDynamics.jl supports both EM and VI. For LDS models, we can use Laplace EM, where we approximate the posterior of the latent state path using the Laplace approximation as outlined above. Using these approximate posteriors (or exact ones in the Gaussian case), we can apply closed-form updates for the model parameters.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StateSpaceDynamics.fit!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{LinearDynamicalSystem{T, S, O}, AbstractArray{T, 3}}} where {T&lt;:Real, S&lt;:(GaussianStateModel{T, M, V} where {M&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}), O&lt;:AbstractObservationModel{T}}" href="#StateSpaceDynamics.fit!-Union{Tuple{O}, Tuple{S}, Tuple{T}, Tuple{LinearDynamicalSystem{T, S, O}, AbstractArray{T, 3}}} where {T&lt;:Real, S&lt;:(GaussianStateModel{T, M, V} where {M&lt;:AbstractMatrix{T}, V&lt;:AbstractVector{T}}), O&lt;:AbstractObservationModel{T}}"><code>StateSpaceDynamics.fit!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit!(lds, y; max_iter::Int=1000, tol::Real=1e-12) 
where {T&lt;:Real, S&lt;:GaussianStateModel{T}, O&lt;:GaussianObservationModel{T}}</code></pre><p>Fit a Linear Dynamical System using the Expectation-Maximization (EM) algorithm with Kalman smoothing over multiple trials</p><p><strong>Arguments</strong></p><ul><li><code>lds::LinearDynamicalSystem{T,S,O}</code>: The Linear Dynamical System to be fitted.</li><li><code>y::AbstractArray{T,3}</code>: Observed data, size(obs<em>dim, T</em>steps, n_trials)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>max_iter::Int=1000</code>: Maximum number of EM iterations.</li><li><code>tol::T=1e-12</code>: Convergence tolerance for log-likelihood change.</li></ul><p><strong>Returns</strong></p><ul><li><code>mls::Vector{T}</code>: Vector of log-likelihood values for each iteration.</li><li><code>param_diff::Vector{T}</code>: Vector of parameter deltas for each EM iteration. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/91525d17b53ab12d81655c5c80c04e315c400b49/src/LinearDynamicalSystems.jl#L1015-L1032">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../HiddenMarkovModels/">Hidden Markov Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Friday 13 June 2025 17:40">Friday 13 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
