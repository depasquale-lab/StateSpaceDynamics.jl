<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Poisson LDS Example · StateSpaceDynamics.jl</title><meta name="title" content="Poisson LDS Example · StateSpaceDynamics.jl"/><meta property="og:title" content="Poisson LDS Example · StateSpaceDynamics.jl"/><meta property="twitter:title" content="Poisson LDS Example · StateSpaceDynamics.jl"/><meta name="description" content="Documentation for StateSpaceDynamics.jl."/><meta property="og:description" content="Documentation for StateSpaceDynamics.jl."/><meta property="twitter:description" content="Documentation for StateSpaceDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../LinearDynamicalSystems/">Linear Dynamical Systems</a></li><li><a class="tocitem" href="../../HiddenMarkovModels/">Hidden Markov Models</a></li><li><a class="tocitem" href="../../SLDS/">Switching Linear Dynamical Systems</a></li><li><a class="tocitem" href="../../EmissionModels/">EmissionModels</a></li><li><a class="tocitem" href="../../MixtureModels/">Mixture Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../gaussian_latent_dynamics_example/">Gaussian LDS Example</a></li><li class="is-active"><a class="tocitem" href>Poisson LDS Example</a><ul class="internal"><li><a class="tocitem" href="#Load-Required-Packages"><span>Load Required Packages</span></a></li><li><a class="tocitem" href="#Why-Poisson-Linear-Dynamical-Systems?"><span>Why Poisson Linear Dynamical Systems?</span></a></li><li><a class="tocitem" href="#Create-a-Poisson-Linear-Dynamical-System"><span>Create a Poisson Linear Dynamical System</span></a></li><li><a class="tocitem" href="#Understanding-Poisson-LDS-Parameters"><span>Understanding Poisson LDS Parameters</span></a></li><li><a class="tocitem" href="#The-Exponential-Link-Function"><span>The Exponential Link Function</span></a></li><li><a class="tocitem" href="#Simulate-Latent-States-and-Count-Observations"><span>Simulate Latent States and Count Observations</span></a></li><li><a class="tocitem" href="#Visualize-Latent-Dynamics"><span>Visualize Latent Dynamics</span></a></li><li><a class="tocitem" href="#Visualize-Latent-States-and-Spike-Observations"><span>Visualize Latent States and Spike Observations</span></a></li><li><a class="tocitem" href="#The-Inference-Challenge"><span>The Inference Challenge</span></a></li><li><a class="tocitem" href="#Initialize-and-Fit-Poisson-LDS"><span>Initialize and Fit Poisson LDS</span></a></li><li><a class="tocitem" href="#Fit-Using-Laplace-EM-Algorithm"><span>Fit Using Laplace-EM Algorithm</span></a></li><li><a class="tocitem" href="#Monitor-ELBO-Convergence"><span>Monitor ELBO Convergence</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../lds_model_selection_example/">LDS Model Selection Example</a></li><li><a class="tocitem" href="../lds_identifiability_example/">Non-Identifiability in LDS Models</a></li><li><a class="tocitem" href="../hidden_markov_model_example/">Hidden Markov Model Example</a></li><li><a class="tocitem" href="../hmm_model_selection_example/">HMM Model Selection</a></li><li><a class="tocitem" href="../gaussian_glm_hmm_example/">Gaussian GLM-HMM Example</a></li><li><a class="tocitem" href="../hmm_identifiability_example/">HMM Identifiability</a></li><li><a class="tocitem" href="../gaussian_mixture_model_example/">Gaussian Mixture Model Example</a></li><li><a class="tocitem" href="../poisson_mixture_model_example/">Poisson Mixture Model Example</a></li><li><a class="tocitem" href="../Probabilistic_PCA_example/">Probabilistic PCA Example</a></li><li><a class="tocitem" href="../switching_linear_dynamical_system_example/">Switching Linear Dynamical System Example</a></li></ul></li><li><a class="tocitem" href="../../Misc/">Miscellaneous</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Poisson LDS Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Poisson LDS Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/main/docs/examples/PoissonLDS.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulating-and-Fitting-a-Poisson-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#Simulating-and-Fitting-a-Poisson-Linear-Dynamical-System">Simulating and Fitting a Poisson Linear Dynamical System</a><a id="Simulating-and-Fitting-a-Poisson-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-and-Fitting-a-Poisson-Linear-Dynamical-System" title="Permalink"></a></h1><p>This tutorial demonstrates how to use <code>StateSpaceDynamics.jl</code> to simulate and fit a Linear Dynamical System (LDS) with Poisson observations using the Laplace-EM algorithm. Unlike the standard Gaussian LDS, this model is designed for count data (e.g., neural spike counts, customer arrivals, or discrete event data) where observations are non-negative integers following Poisson distributions.</p><p>The key insight is that while latent dynamics remain continuous and Gaussian, the observations are discrete counts whose rates depend on the latent state through an exponential link function: <span>$\lambda_i(t) = \exp(\mathbf{C}_i^T \mathbf{x}_t + d_i)$</span>.</p><h2 id="Load-Required-Packages"><a class="docs-heading-anchor" href="#Load-Required-Packages">Load Required Packages</a><a id="Load-Required-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Required-Packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using StateSpaceDynamics
using LinearAlgebra
using Random
using Plots
using LaTeXStrings
using StableRNGs</code></pre><p>Set up reproducible random number generation</p><pre><code class="language-julia hljs">rng = StableRNG(54321);</code></pre><h2 id="Why-Poisson-Linear-Dynamical-Systems?"><a class="docs-heading-anchor" href="#Why-Poisson-Linear-Dynamical-Systems?">Why Poisson Linear Dynamical Systems?</a><a id="Why-Poisson-Linear-Dynamical-Systems?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Poisson-Linear-Dynamical-Systems?" title="Permalink"></a></h2><p>Many real-world phenomena involve discrete events generated by underlying continuous processes. Traditional Gaussian LDS assumes continuous observations, but fails when data are:</p><ul><li>Neural spike counts (non-negative integers)</li><li>Customer arrivals per time window</li><li>Gene expression counts</li><li>Social media posts or interactions</li></ul><p>Poisson LDS elegantly handles this by maintaining Gaussian latent dynamics while modeling observations as count data with rates that depend on the hidden state.</p><h2 id="Create-a-Poisson-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#Create-a-Poisson-Linear-Dynamical-System">Create a Poisson Linear Dynamical System</a><a id="Create-a-Poisson-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-Poisson-Linear-Dynamical-System" title="Permalink"></a></h2><p>We define a system where continuous latent dynamics generate discrete count observations. This is particularly relevant in neuroscience (neural spike trains) and other domains where discrete events are generated by underlying continuous processes.</p><pre><code class="language-julia hljs">obs_dim = 10       # Number of observed count variables (e.g., neurons)
latent_dim = 2;    # Number of latent state dimensions</code></pre><p>Define latent dynamics: same spiral structure as Gaussian LDS Latent states evolve smoothly according to linear dynamics</p><pre><code class="language-julia hljs">A = 0.95 * [cos(0.25) -sin(0.25); sin(0.25) cos(0.25)]  # Rotation with contraction
Q = Matrix(0.1 * I(latent_dim))     # Process noise covariance
x0 = zeros(latent_dim)              # Initial state mean
P0 = Matrix(0.1 * I(latent_dim));   # Initial state covariance</code></pre><p>Poisson observation model parameters: For Poisson observations, the rate parameter <span>$\lambda_i$</span> is modeled as: <span>$\log(\lambda_i) = \mathbf{C}_i^T \mathbf{x}_t + d_i$</span> where <span>$\mathbf{C}$</span> maps latent states to log-rates and <span>$d_i$</span> provides baseline log-rates</p><pre><code class="language-julia hljs">log_d = log.(fill(0.1, obs_dim));    # Log baseline rates (small positive rates)</code></pre><p>Observation matrix C: maps 2D latent states to log-rates for each observed dimension Use positive values so latent activity increases firing rates</p><pre><code class="language-julia hljs">C = permutedims([abs.(randn(rng, obs_dim))&#39;; abs.(randn(rng, obs_dim))&#39;]);</code></pre><h2 id="Understanding-Poisson-LDS-Parameters"><a class="docs-heading-anchor" href="#Understanding-Poisson-LDS-Parameters">Understanding Poisson LDS Parameters</a><a id="Understanding-Poisson-LDS-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-Poisson-LDS-Parameters" title="Permalink"></a></h2><p><strong>Latent dynamics parameters (same as Gaussian LDS):</strong></p><ul><li>A: How latent states evolve (rotation + contraction creates stable oscillation)</li><li>Q: Process noise (uncertainty in latent evolution)</li><li>x0, P0: Initial state distribution</li></ul><p><strong>Observation parameters (unique to Poisson case):</strong></p><ul><li>C[i,:]: How latent dimensions affect log-rate of observation i<ul><li>Positive C[i,j]: latent dimension j increases firing rate of unit i</li><li>Negative C[i,j]: latent dimension j decreases firing rate of unit i</li></ul></li><li>d[i]: Baseline log-rate for observation i when latent state = 0<ul><li>exp(d[i]) gives the baseline firing rate</li></ul></li></ul><h2 id="The-Exponential-Link-Function"><a class="docs-heading-anchor" href="#The-Exponential-Link-Function">The Exponential Link Function</a><a id="The-Exponential-Link-Function-1"></a><a class="docs-heading-anchor-permalink" href="#The-Exponential-Link-Function" title="Permalink"></a></h2><p>The key innovation is how we connect continuous latent states to discrete counts. Instead of linear observations y = Cx + noise, we use:</p><p class="math-container">\[λᵢ(t) = exp(Cᵢᵀx_t + dᵢ)\]</p><p class="math-container">\[yᵢ(t) ~ Poisson(λᵢ(t))\]</p><p>The exponential ensures rates are always positive (required for Poisson), and the log-linear relationship means latent states multiplicatively affect firing rates.</p><p>The baseline parameter d_i sets the minimum firing rate when latent states are zero.</p><p>Construct the model components</p><pre><code class="language-julia hljs">state_model = GaussianStateModel(; A, Q, x0, P0)          # Gaussian latent dynamics
obs_model = PoissonObservationModel(; C, log_d);           # Poisson observations</code></pre><p>Create the complete Poisson Linear Dynamical System</p><pre><code class="language-julia hljs">true_plds = LinearDynamicalSystem(;
    state_model=state_model,
    obs_model=obs_model,
    latent_dim=latent_dim,
    obs_dim=obs_dim,
    fit_bool=fill(true, 6)  # Learn all parameters: A, Q, C, log_d, x0, P0
);</code></pre><h2 id="Simulate-Latent-States-and-Count-Observations"><a class="docs-heading-anchor" href="#Simulate-Latent-States-and-Count-Observations">Simulate Latent States and Count Observations</a><a id="Simulate-Latent-States-and-Count-Observations-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-Latent-States-and-Count-Observations" title="Permalink"></a></h2><p>Generate synthetic data from our Poisson LDS. Latent states evolve according to linear dynamics, while observations are drawn from Poisson distributions whose rates depend exponentially on the current latent state.</p><p>Generate both latent trajectories and count observations</p><pre><code class="language-julia hljs">tSteps = 500
latents, observations = rand(rng, true_plds; tsteps=tSteps, ntrials=1);</code></pre><h2 id="Visualize-Latent-Dynamics"><a class="docs-heading-anchor" href="#Visualize-Latent-Dynamics">Visualize Latent Dynamics</a><a id="Visualize-Latent-Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-Latent-Dynamics" title="Permalink"></a></h2><p>Show the underlying continuous dynamics that drive discrete observations. This vector field illustrates how latent states evolve deterministically (ignoring noise).</p><p>Create grid for vector field</p><pre><code class="language-julia hljs">x = y = -3:0.5:3
X = repeat(x&#39;, length(y), 1)
Y = repeat(y, 1, length(x))
U = zeros(size(X))  # Flow in x-direction
V = zeros(size(Y));  # Flow in y-direction

for i in 1:size(X, 1), j in 1:size(X, 2)
    v = A * [X[i,j], Y[i,j]]
    U[i,j] = v[1] - X[i,j]
    V[i,j] = v[2] - Y[i,j]
end

magnitude = @. sqrt(U^2 + V^2)  # Normalize arrow lengths for cleaner visualization
U_norm = U ./ magnitude
V_norm = V ./ magnitude;</code></pre><p>Plot vector field with simulated trajectory</p><pre><code class="language-julia hljs">p1 = quiver(X, Y, quiver=(U_norm, V_norm), color=:blue, alpha=0.3,
           linewidth=1, arrow=arrow(:closed, :head, 0.1, 0.1))
plot!(latents[1, :, 1], latents[2, :, 1], xlabel=L&quot;x_1&quot;, ylabel=L&quot;x_2&quot;,
      color=:black, linewidth=1.5, title=&quot;Latent Dynamics&quot;, legend=false)</code></pre><img src="86a94f36.svg" alt="Example block output"/><h2 id="Visualize-Latent-States-and-Spike-Observations"><a class="docs-heading-anchor" href="#Visualize-Latent-States-and-Spike-Observations">Visualize Latent States and Spike Observations</a><a id="Visualize-Latent-States-and-Spike-Observations-1"></a><a class="docs-heading-anchor-permalink" href="#Visualize-Latent-States-and-Spike-Observations" title="Permalink"></a></h2><p>Create visualizations highlighting the contrast between continuous latent dynamics and discrete count observations (spike trains).</p><pre><code class="language-julia hljs">states = latents[:, :, 1]
emissions = observations[:, :, 1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10×500 Matrix{Float64}:
 0.0  1.0  0.0  11.0  7.0  2.0  4.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  0.0  2.0   1.0  3.0  6.0  1.0     1.0  1.0  0.0  0.0  1.0  0.0  0.0
 0.0  1.0  1.0   3.0  2.0  3.0  1.0     2.0  0.0  1.0  0.0  1.0  0.0  0.0
 2.0  2.0  2.0   2.0  3.0  0.0  2.0     1.0  1.0  0.0  0.0  0.0  1.0  1.0
 0.0  0.0  2.0   2.0  3.0  5.0  7.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 1.0  2.0  1.0   2.0  1.0  3.0  2.0  …  1.0  0.0  0.0  0.0  0.0  1.0  1.0
 2.0  2.0  2.0   4.0  1.0  0.0  0.0     1.0  0.0  0.0  1.0  0.0  1.0  0.0
 1.0  1.0  0.0   1.0  1.0  1.0  6.0     0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0   3.0  5.0  1.0  4.0     0.0  0.0  0.0  0.0  0.0  2.0  0.0
 0.0  2.0  1.0   1.0  5.0  3.0  1.0     1.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><p>Two-panel layout: continuous latent states above, discrete spike rasters below</p><pre><code class="language-julia hljs">lim_states = maximum(abs.(states))

p2 = plot(size=(800, 600), layout=@layout[a{0.3h}; b])

for d in 1:latent_dim
    plot!(1:tSteps, states[d, :] .+ lim_states * (d-1), color=:black,
          linewidth=2, label=&quot;&quot;, subplot=1) # Plot smooth latent state trajectories

end

plot!(subplot=1, yticks=(lim_states .* (0:latent_dim-1), [L&quot;x_%$d&quot; for d in 1:latent_dim]),
      xticks=[], xlims=(0, tSteps), title=&quot;Simulated Latent States&quot;,
      yformatter=y-&gt;&quot;&quot;, tickfontsize=12)

colors = palette(:default, obs_dim)
for f in 1:obs_dim
    spike_times = findall(x -&gt; x &gt; 0, emissions[f, :])
    for t in spike_times
        plot!([t, t], [f-0.4, f+0.4], color=colors[f], linewidth=1, label=&quot;&quot;, subplot=2)
    end
end

plot!(subplot=2, yticks=(1:obs_dim, [L&quot;y_{%$d}&quot; for d in 1:obs_dim]),
      xlims=(0, tSteps), ylims=(0.5, obs_dim + 0.5), title=&quot;Spike Raster Plot&quot;,
      xlabel=&quot;Time&quot;, tickfontsize=12, grid=false)</code></pre><img src="54700201.svg" alt="Example block output"/><h2 id="The-Inference-Challenge"><a class="docs-heading-anchor" href="#The-Inference-Challenge">The Inference Challenge</a><a id="The-Inference-Challenge-1"></a><a class="docs-heading-anchor-permalink" href="#The-Inference-Challenge" title="Permalink"></a></h2><p>Unlike Gaussian LDS where exact inference is possible via Kalman filtering, Poisson observations break the conjugate Gaussian structure. The posterior <span>$p(x_t | y_{1:T})$</span> is no longer Gaussian, requiring approximations.</p><p><strong>Laplace-EM Algorithm</strong>:</p><ul><li><strong>E-step</strong>: Use Laplace approximation to make posterior &quot;locally Gaussian&quot;</li><li><strong>M-step</strong>: Update parameters using expected sufficient statistics</li><li><strong>Iteration</strong>: Repeat until ELBO converges</li></ul><p>The Laplace approximation finds the mode of the posterior and approximates it with a Gaussian, enabling tractable inference at the cost of some accuracy.</p><h2 id="Initialize-and-Fit-Poisson-LDS"><a class="docs-heading-anchor" href="#Initialize-and-Fit-Poisson-LDS">Initialize and Fit Poisson LDS</a><a id="Initialize-and-Fit-Poisson-LDS-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-and-Fit-Poisson-LDS" title="Permalink"></a></h2><p>In practice, we only observe spike counts, not latent states. Our goal is to infer both latent dynamics and the mapping from latent states to firing rates. Start with randomly initialized model.</p><p>Random initialization (simulating lack of prior knowledge)</p><pre><code class="language-julia hljs">A_init = random_rotation_matrix(latent_dim, rng)  # Random rotation matrix
Q_init = Matrix(0.1 * I(latent_dim))              # Process noise guess
C_init = randn(rng, obs_dim, latent_dim)          # Random observation mapping
log_d_init = log.(fill(0.1, obs_dim))             # Baseline log-rate guess
x0_init = zeros(latent_dim)                       # Start from origin
P0_init = Matrix(0.1 * I(latent_dim));             # Initial uncertainty</code></pre><p>Construct naive model</p><pre><code class="language-julia hljs">sm_init = GaussianStateModel(; A=A_init, Q=Q_init, x0=x0_init, P0=P0_init)
om_init = PoissonObservationModel(; C=C_init, log_d=log_d_init)

naive_plds = LinearDynamicalSystem(;
    state_model=sm_init,
    obs_model=om_init,
    latent_dim=latent_dim,
    obs_dim=obs_dim,
    fit_bool=fill(true, 6)
);</code></pre><p>For Poisson observations, this requires Laplace approximations since the posterior is no longer Gaussian (unlike linear-Gaussian case)</p><pre><code class="language-julia hljs">smoothed_x_pre, smoothed_p_pre = smooth(naive_plds, observations);</code></pre><p>Compare true vs. initial estimated latent states</p><pre><code class="language-julia hljs">p3 = plot()
for d in 1:latent_dim
    plot!(1:tSteps, states[d, :] .+ lim_states * (d-1), color=:black,
          linewidth=2, label=(d==1 ? &quot;True&quot; : &quot;&quot;), alpha=0.8)
    plot!(1:tSteps, smoothed_x_pre[d, :, 1] .+ lim_states * (d-1), color=:red,
          linewidth=2, label=(d==1 ? &quot;Initial Est.&quot; : &quot;&quot;), alpha=0.8)
end

plot!(yticks=(lim_states .* (0:latent_dim-1), [L&quot;x_%$d&quot; for d in 1:latent_dim]),
      xlabel=&quot;Time&quot;, xlims=(0, tSteps), title=&quot;Pre-EM: True vs. Initial Estimates&quot;,
      yformatter=y-&gt;&quot;&quot;, tickfontsize=12, legend=:topright)</code></pre><img src="9482e1e8.svg" alt="Example block output"/><h2 id="Fit-Using-Laplace-EM-Algorithm"><a class="docs-heading-anchor" href="#Fit-Using-Laplace-EM-Algorithm">Fit Using Laplace-EM Algorithm</a><a id="Fit-Using-Laplace-EM-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-Using-Laplace-EM-Algorithm" title="Permalink"></a></h2><p>Fit the model - using fewer iterations due to computational cost</p><pre><code class="language-julia hljs">elbo, _ = fit!(naive_plds, observations; max_iter=25, tol=1e-6);

print(&quot;Laplace-EM completed in $(length(elbo)) iterations\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Fitting Poisson LDS via LaPlaceEM...   8%|████                                              |  ETA: 0:00:12 ( 0.53  s/it)Fitting Poisson LDS via LaPlaceEM...  36%|██████████████████                                |  ETA: 0:00:02 ( 0.13  s/it)Fitting Poisson LDS via LaPlaceEM...  64%|████████████████████████████████                  |  ETA: 0:00:01 (80.22 ms/it)Fitting Poisson LDS via LaPlaceEM...  96%|████████████████████████████████████████████████  |  ETA: 0:00:00 (58.15 ms/it)Fitting Poisson LDS via LaPlaceEM... 100%|██████████████████████████████████████████████████| Time: 0:00:01 (56.33 ms/it)
Laplace-EM completed in 25 iterations</code></pre><p><strong>Parameter identifiability:</strong></p><ul><li>Scale ambiguity: (C, d) and (αC, d + log(α)) give same likelihood</li><li>Can be resolved by constraining norm of C or fixing one element</li><li>Rotation ambiguity in latent space (same as Gaussian LDS)</li></ul><p>Perform smoothing with learned parameters</p><pre><code class="language-julia hljs">smoothed_x_post, smoothed_p_post = smooth(naive_plds, observations);</code></pre><p>Compare true vs. learned latent state estimates</p><pre><code class="language-julia hljs">p4 = plot()
for d in 1:latent_dim
    plot!(1:tSteps, states[d, :] .+ lim_states * (d-1), color=:black,
          linewidth=2, label=(d==1 ? &quot;True&quot; : &quot;&quot;), alpha=0.8)
    plot!(1:tSteps, smoothed_x_post[d, :, 1] .+ lim_states * (d-1), color=:red,
          linewidth=2, label=(d==1 ? &quot;Post-EM Est.&quot; : &quot;&quot;), alpha=0.8)
end

plot!(yticks=(lim_states .* (0:latent_dim-1), [L&quot;x_%$d&quot; for d in 1:latent_dim]),
      xlabel=&quot;Time&quot;, xlims=(0, tSteps), title=&quot;Post-EM: True vs. Learned Estimates&quot;,
      yformatter=y-&gt;&quot;&quot;, tickfontsize=12, legend=:topright)</code></pre><img src="529cc2aa.svg" alt="Example block output"/><h2 id="Monitor-ELBO-Convergence"><a class="docs-heading-anchor" href="#Monitor-ELBO-Convergence">Monitor ELBO Convergence</a><a id="Monitor-ELBO-Convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Monitor-ELBO-Convergence" title="Permalink"></a></h2><p>The Evidence Lower Bound (ELBO) tracks algorithm progress. For Poisson LDS, ELBO includes both data likelihood and Laplace approximation terms. Convergence may be less smooth than Gaussian case due to approximations.</p><pre><code class="language-julia hljs">p5 = plot(elbo, xlabel=&quot;Iteration&quot;, ylabel=&quot;ELBO&quot;,
          title=&quot;Laplace-EM Convergence&quot;, legend=false,
          linewidth=2, marker=:circle, markersize=3, color=:darkgreen)

if length(elbo) &gt; 1
    improvement = elbo[end] - elbo[1]
    annotate!(p5, length(elbo)*0.7, elbo[end]*0.95,
        text(&quot;Improvement: $(round(improvement, digits=1))&quot;, 10)) # Add convergence annotation
end</code></pre><img src="8ca3eecb.svg" alt="Example block output"/><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial demonstrated fitting a Poisson Linear Dynamical System:</p><p><strong>Key Concepts:</strong></p><ul><li><strong>Hybrid model</strong>: Continuous Gaussian latent dynamics generate discrete Poisson observations</li><li><strong>Exponential link</strong>: <span>$\log(\lambda_i) = \mathbf{C}_i^T \mathbf{x}_t + d_i$</span> connects latent states to count rates</li><li><strong>Laplace-EM</strong>: Handles non-conjugate Poisson-Gaussian combination through approximations</li><li><strong>Count data modeling</strong>: Extends LDS framework to spike trains and event sequences</li></ul><p><strong>Technical Insights:</strong></p><ul><li>More computationally intensive than Gaussian LDS due to required approximations</li><li>Convergence can be slower and less smooth than conjugate models</li><li>Parameter recovery quality depends on observation density and latent state separation</li><li>Laplace approximations become more accurate with higher count rates</li></ul><p><strong>Advantages:</strong></p><ul><li>Principled probabilistic framework for count data</li><li>Maintains interpretable continuous latent dynamics</li><li>Enables simultaneous state estimation and parameter learning</li><li>Provides uncertainty quantification for both states and parameters</li></ul><p>The Poisson LDS successfully bridges continuous dynamical systems and discrete observation models, enabling principled analysis of count data with underlying temporal structure.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gaussian_latent_dynamics_example/">« Gaussian LDS Example</a><a class="docs-footer-nextpage" href="../lds_model_selection_example/">LDS Model Selection Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 19 September 2025 15:10">Friday 19 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
