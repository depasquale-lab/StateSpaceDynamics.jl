<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gaussian LDS Example · StateSpaceDynamics.jl</title><meta name="title" content="Gaussian LDS Example · StateSpaceDynamics.jl"/><meta property="og:title" content="Gaussian LDS Example · StateSpaceDynamics.jl"/><meta property="twitter:title" content="Gaussian LDS Example · StateSpaceDynamics.jl"/><meta name="description" content="Documentation for StateSpaceDynamics.jl."/><meta property="og:description" content="Documentation for StateSpaceDynamics.jl."/><meta property="twitter:description" content="Documentation for StateSpaceDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../LinearDynamicalSystems/">Linear Dynamical Systems</a></li><li><a class="tocitem" href="../../HiddenMarkovModels/">Hidden Markov Models</a></li><li><a class="tocitem" href="../../SLDS/">Switching Linear Dynamical Systems</a></li><li><a class="tocitem" href="../../EmissionModels/">EmissionModels</a></li><li><a class="tocitem" href="../../MixtureModels/">Mixture Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Gaussian LDS Example</a><ul class="internal"><li><a class="tocitem" href="#Simulating-and-Fitting-a-Linear-Dynamical-System"><span>Simulating and Fitting a Linear Dynamical System</span></a></li><li><a class="tocitem" href="#Load-Required-Packages"><span>Load Required Packages</span></a></li><li><a class="tocitem" href="#Create-a-State-Space-Model"><span>Create a State-Space Model</span></a></li><li><a class="tocitem" href="#Simulate-Latent-and-Observed-Data"><span>Simulate Latent and Observed Data</span></a></li><li><a class="tocitem" href="#Plot-Vector-Field-of-Latent-Dynamics"><span>Plot Vector Field of Latent Dynamics</span></a></li><li><a class="tocitem" href="#Plot-Latent-States-and-Observations"><span>Plot Latent States and Observations</span></a></li><li><a class="tocitem" href="#Initialize-a-Model-and-Perform-Smoothing"><span>Initialize a Model and Perform Smoothing</span></a></li><li><a class="tocitem" href="#Fit-Model-Using-EM-Algorithm"><span>Fit Model Using EM Algorithm</span></a></li><li><a class="tocitem" href="#Confirm-Model-Convergence"><span>Confirm Model Convergence</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../poisson_latent_dynamics_example/">Poisson LDS Example</a></li><li><a class="tocitem" href="../hidden_markov_model_example/">Hidden Markov Model Example</a></li><li><a class="tocitem" href="../gaussian_glm_hmm_example/">Gaussian GLM-GMM Example</a></li><li><a class="tocitem" href="../gaussian_mixture_model_example/">Gaussian Mixture Model Example</a></li><li><a class="tocitem" href="../poisson_mixture_model_example/">Poisson Mixture Model Example</a></li><li><a class="tocitem" href="../Probabilistic_PCA_example/">Probabilistic PCA Example</a></li><li><a class="tocitem" href="../switching_linear_dynamical_system_example/">Switching Linear Dynamical System Example</a></li></ul></li><li><a class="tocitem" href="../../Misc/">Miscellaneous</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Gaussian LDS Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gaussian LDS Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/main/docs/examples/GaussianLDS.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Simulating-and-Fitting-a-Linear-Dynamical-System"><a class="docs-heading-anchor" href="#Simulating-and-Fitting-a-Linear-Dynamical-System">Simulating and Fitting a Linear Dynamical System</a><a id="Simulating-and-Fitting-a-Linear-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-and-Fitting-a-Linear-Dynamical-System" title="Permalink"></a></h2><p>This tutorial demonstrates how to use <code>StateSpaceDynamics.jl</code> to simulate a latent linear dynamical system and fit it using the EM algorithm. We&#39;ll walk through the complete workflow: defining a true model, generating synthetic data, initializing a naive model, and then learning the parameters through iterative optimization.</p><h2 id="Load-Required-Packages"><a class="docs-heading-anchor" href="#Load-Required-Packages">Load Required Packages</a><a id="Load-Required-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Required-Packages" title="Permalink"></a></h2><p>We begin by loading all the necessary packages for our analysis. StateSpaceDynamics.jl provides the core functionality, while the other packages handle linear algebra, random number generation, plotting, and mathematical notation.</p><pre><code class="language-julia hljs">using StateSpaceDynamics
using LinearAlgebra
using Random
using Plots
using LaTeXStrings
using StableRNGs</code></pre><p>Set a stable random number generator for reproducible results</p><pre><code class="language-julia hljs">rng = StableRNG(123);</code></pre><h2 id="Create-a-State-Space-Model"><a class="docs-heading-anchor" href="#Create-a-State-Space-Model">Create a State-Space Model</a><a id="Create-a-State-Space-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-State-Space-Model" title="Permalink"></a></h2><p>We start by defining the dimensions of our system. A linear dynamical system (LDS) models how a low-dimensional latent state evolves over time and generates high-dimensional observations. Here we use a 2D latent space (which we can visualize easily) that generates 10-dimensional observations.</p><pre><code class="language-julia hljs">obs_dim = 10      # Number of observed variables at each time step
latent_dim = 2    # Number of latent state variables</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>Define the state transition matrix A. This matrix governs how the latent state evolves from one time step to the next: x<em>{t+1} = A * x</em>t + noise. We create a rotation matrix scaled by 0.95, which creates a stable spiral dynamic that slowly contracts toward the origin.</p><pre><code class="language-julia hljs">A = 0.95 * [cos(0.25) -sin(0.25); sin(0.25) cos(0.25)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.920467  -0.235034
 0.235034   0.920467</code></pre><p>Process noise covariance Q controls how much random variation we add to the latent state transitions. A smaller Q means more predictable dynamics.</p><pre><code class="language-julia hljs">Q = Matrix(0.1 * I(2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.1  0.0
 0.0  0.1</code></pre><p>Initial state parameters: where the latent trajectory starts and how uncertain we are about this initial position.</p><pre><code class="language-julia hljs">x0 = [0.0; 0.0]           # Mean of initial state
P0 = Matrix(0.1 * I(2))   # Covariance of initial state</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.1  0.0
 0.0  0.1</code></pre><p>Observation parameters: how the latent states map to observed data. C is the observation matrix (latent-to-observed mapping), and R is the observation noise covariance.</p><pre><code class="language-julia hljs">C = randn(rng, obs_dim, latent_dim)  # Random linear mapping from 2D latent to 10D observed
R = Matrix(0.5 * I(obs_dim))         # Independent noise on each observation dimension</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10×10 Matrix{Float64}:
 0.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.5  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.5  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.5  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.5  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.5</code></pre><p>Construct the state and observation model components</p><pre><code class="language-julia hljs">true_gaussian_sm = GaussianStateModel(;A=A, Q=Q, x0=x0, P0=P0)
true_gaussian_om = GaussianObservationModel(;C=C, R=R)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GaussianObservationModel{Float64, Matrix{Float64}}([-0.12683768965424458 -0.9995722599695167; 0.6668851724871252 -1.4919831226368483; … ; -0.9671975288083468 -0.3274601670258862; -1.3641880343579902 -0.5067518363436612], [0.5 0.0 … 0.0 0.0; 0.0 0.5 … 0.0 0.0; … ; 0.0 0.0 … 0.5 0.0; 0.0 0.0 … 0.0 0.5])</code></pre><p>Combine them into a complete Linear Dynamical System The fit_bool parameter indicates which parameters should be learned during fitting</p><pre><code class="language-julia hljs">true_lds = LinearDynamicalSystem(;
    state_model=true_gaussian_sm,
    obs_model=true_gaussian_om,
    latent_dim=latent_dim,
    obs_dim=obs_dim,
    fit_bool=fill(true, 6)  # Fit all 6 parameter matrices: A, Q, C, R, x0, P0
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}(GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}([0.9204668006251124 -0.2350337612917968; 0.2350337612917968 0.9204668006251124], [0.1 0.0; 0.0 0.1], [0.0, 0.0], [0.1 0.0; 0.0 0.1]), GaussianObservationModel{Float64, Matrix{Float64}}([-0.12683768965424458 -0.9995722599695167; 0.6668851724871252 -1.4919831226368483; … ; -0.9671975288083468 -0.3274601670258862; -1.3641880343579902 -0.5067518363436612], [0.5 0.0 … 0.0 0.0; 0.0 0.5 … 0.0 0.0; … ; 0.0 0.0 … 0.5 0.0; 0.0 0.0 … 0.0 0.5]), 2, 10, Bool[1, 1, 1, 1, 1, 1])</code></pre><h2 id="Simulate-Latent-and-Observed-Data"><a class="docs-heading-anchor" href="#Simulate-Latent-and-Observed-Data">Simulate Latent and Observed Data</a><a id="Simulate-Latent-and-Observed-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-Latent-and-Observed-Data" title="Permalink"></a></h2><p>Now we generate synthetic data from our true model. This gives us both the latent states (which we&#39;ll later try to recover) and the observations (which is all a real algorithm would see).</p><pre><code class="language-julia hljs">tSteps = 500  # Number of time points to simulate</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">500</code></pre><p>The rand function generates both latent trajectories and corresponding observations</p><pre><code class="language-julia hljs">latents, observations = rand(rng, true_lds; tsteps=tSteps, ntrials=1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.3302411483795398 0.30287095528698343 … -0.06670541876666242 -0.17921452288240727; -0.31796663176380235 -0.3171044904594342 … 1.4125315970448002 1.2103765402396673;;;], [-0.10983625829671911 1.6264648985386785 … -2.386760414932026 -1.1755792249265034; 1.1615730946048897 1.4717874431185893 … -2.974657918966271 -1.9995874486572618; … ; -0.5933847030613173 -1.1111410198929672 … -0.7690775611482195 0.23287537282242812; -1.2316865274907531 -0.7610659908580879 … 0.3534417293032205 -2.098209673926211;;;])</code></pre><h2 id="Plot-Vector-Field-of-Latent-Dynamics"><a class="docs-heading-anchor" href="#Plot-Vector-Field-of-Latent-Dynamics">Plot Vector Field of Latent Dynamics</a><a id="Plot-Vector-Field-of-Latent-Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Vector-Field-of-Latent-Dynamics" title="Permalink"></a></h2><p>To better understand the dynamics encoded by our transition matrix A, we&#39;ll create a vector field plot. This shows how the latent state would evolve from any starting point in the 2D latent space.</p><p>Create a grid of starting points</p><pre><code class="language-julia hljs">x = y = -3:0.5:3
X = repeat(x&#39;, length(y), 1)
Y = repeat(y, 1, length(x))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13×13 Matrix{Float64}:
 -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0  -3.0
 -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5  -2.5
 -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0  -2.0
 -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5  -1.5
 -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0  -1.0
 -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5  -0.5
  0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0   0.0
  0.5   0.5   0.5   0.5   0.5   0.5   0.5   0.5   0.5   0.5   0.5   0.5   0.5
  1.0   1.0   1.0   1.0   1.0   1.0   1.0   1.0   1.0   1.0   1.0   1.0   1.0
  1.5   1.5   1.5   1.5   1.5   1.5   1.5   1.5   1.5   1.5   1.5   1.5   1.5
  2.0   2.0   2.0   2.0   2.0   2.0   2.0   2.0   2.0   2.0   2.0   2.0   2.0
  2.5   2.5   2.5   2.5   2.5   2.5   2.5   2.5   2.5   2.5   2.5   2.5   2.5
  3.0   3.0   3.0   3.0   3.0   3.0   3.0   3.0   3.0   3.0   3.0   3.0   3.0</code></pre><p>Calculate the flow field: at each point (x,y), compute where it would move in one time step under the dynamics x<em>{t+1} = A * x</em>t</p><pre><code class="language-julia hljs">U = zeros(size(X))  # x-component of flow
V = zeros(size(Y))  # y-component of flow

for i in 1:size(X, 1)
    for j in 1:size(X, 2)
        v = A * [X[i,j], Y[i,j]]
        U[i,j] = v[1] - X[i,j]  # Change in x
        V[i,j] = v[2] - Y[i,j]  # Change in y
    end
end</code></pre><p>Normalize arrows for cleaner visualization</p><pre><code class="language-julia hljs">magnitude = @. sqrt(U^2 + V^2)
U_norm = U ./ magnitude
V_norm = V ./ magnitude</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13×13 Matrix{Float64}:
 -0.443144  -0.360164  -0.25873   -0.136921  …  0.792134  0.852648  0.89645
 -0.522485  -0.443144  -0.341437  -0.212492     0.84203   0.89645   0.932889
 -0.610347  -0.53943   -0.443144  -0.311913     0.89645   0.939904  0.96595
 -0.703886  -0.647334  -0.565468  -0.443144     0.950111  0.977163  0.990582
 -0.797265  -0.760443  -0.703886  -0.610347     0.990582  0.998531  0.99999
 -0.881652  -0.865979  -0.841213  -0.797265  …  0.996696  0.991704  0.987044
 -0.947236  -0.947236  -0.947236  -0.947236     0.947236  0.947236  0.947236
 -0.987044  -0.991704  -0.996696  -0.99999      0.841213  0.865979  0.881652
 -0.99999   -0.998531  -0.990582  -0.96595      0.703886  0.760443  0.797265
 -0.990582  -0.977163  -0.950111  -0.89645      0.565468  0.647334  0.703886
 -0.96595   -0.939904  -0.89645   -0.82477   …  0.443144  0.53943   0.610347
 -0.932889  -0.89645   -0.84203   -0.762206     0.341437  0.443144  0.522485
 -0.89645   -0.852648  -0.792134  -0.710313     0.25873   0.360164  0.443144</code></pre><p>Create the vector field plot with the actual trajectory overlaid</p><pre><code class="language-julia hljs">p = quiver(X, Y, quiver=(U_norm, V_norm), color=:blue, alpha=0.3,
           linewidth=1, arrow=arrow(:closed, :head, 0.1, 0.1))
plot!(latents[1, :, 1], latents[2, :, 1], xlabel=&quot;x₁&quot;, ylabel=&quot;x₂&quot;,
      color=:black, linewidth=1.5, title=&quot;Latent Dynamics&quot;, legend=false)</code></pre><img src="52dd572d.svg" alt="Example block output"/><h2 id="Plot-Latent-States-and-Observations"><a class="docs-heading-anchor" href="#Plot-Latent-States-and-Observations">Plot Latent States and Observations</a><a id="Plot-Latent-States-and-Observations-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-Latent-States-and-Observations" title="Permalink"></a></h2><p>Let&#39;s visualize both the latent states (which evolve smoothly according to our dynamics) and the observations (which are noisy linear combinations of the latents).</p><pre><code class="language-julia hljs">states = latents[:, :, 1]      # Extract the latent trajectory
emissions = observations[:, :, 1]  # Extract the observed data</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10×500 Matrix{Float64}:
 -0.109836   1.62646    0.305773  …   0.259882  -2.38676   -1.17558
  1.16157    1.47179    1.2767       -1.3422    -2.97466   -1.99959
 -0.535784   1.61908   -2.90383      -1.8911    -0.905278  -1.38911
 -0.704221   0.118233   1.03898       0.4522     1.65934    0.888007
 -0.951186  -0.134974   0.256276      0.49476    3.22739    2.69514
 -0.67792    0.899642   0.340639  …   1.79581    1.60931    1.96242
 -0.287087  -1.58844    0.601065      0.299204   0.347727  -1.11617
 -0.900209  -0.560491   0.396818      0.6002     0.739069   1.27299
 -0.593385  -1.11114   -0.47825      -0.148083  -0.769078   0.232875
 -1.23169   -0.761066  -1.13251      -1.0474     0.353442  -2.09821</code></pre><p>Create a two-panel plot: latent states on top, observations below</p><pre><code class="language-julia hljs">plot(size=(800, 600), layout=@layout[a{0.3h}; b])</code></pre><img src="605a6c90.svg" alt="Example block output"/><p>Plot latent states (offset vertically for clarity)</p><pre><code class="language-julia hljs">lim_states = maximum(abs.(states))
for d in 1:latent_dim
    plot!(1:tSteps, states[d, :] .+ lim_states * (d-1), color=:black,
          linewidth=2, label=&quot;&quot;, subplot=1)
end

plot!(subplot=1, yticks=(lim_states .* (0:latent_dim-1), [L&quot;x_%$d&quot; for d in 1:latent_dim]),
      xticks=[], xlims=(0, tSteps), title=&quot;Simulated Latent States&quot;,
      yformatter=y-&gt;&quot;&quot;, tickfontsize=12)</code></pre><img src="20f5df74.svg" alt="Example block output"/><p>Plot observations (also offset vertically since there are many dimensions)</p><pre><code class="language-julia hljs">lim_emissions = maximum(abs.(emissions))
for n in 1:obs_dim
    plot!(1:tSteps, emissions[n, :] .- lim_emissions * (n-1), color=:black,
          linewidth=2, label=&quot;&quot;, subplot=2)
end

plot!(subplot=2, yticks=(-lim_emissions .* (obs_dim-1:-1:0), [L&quot;y_{%$n}&quot; for n in 1:obs_dim]),
      xlabel=&quot;time&quot;, xlims=(0, tSteps), title=&quot;Simulated Emissions&quot;,
      yformatter=y-&gt;&quot;&quot;, tickfontsize=12)

plot!(link=:x, size=(800, 600), left_margin=10Plots.mm)</code></pre><img src="c4a8d04f.svg" alt="Example block output"/><h2 id="Initialize-a-Model-and-Perform-Smoothing"><a class="docs-heading-anchor" href="#Initialize-a-Model-and-Perform-Smoothing">Initialize a Model and Perform Smoothing</a><a id="Initialize-a-Model-and-Perform-Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-a-Model-and-Perform-Smoothing" title="Permalink"></a></h2><p>In a real scenario, we would only observe the emissions, not the latent states. Our goal is to learn the parameters A, Q, C, R from the observations alone. We start by creating a &quot;naive&quot; model with random initial parameters.</p><p>Initialize with random parameters (this simulates not knowing the true system)</p><pre><code class="language-julia hljs">A_init = random_rotation_matrix(2, rng)    # Random rotation matrix for dynamics
Q_init = Matrix(0.1 * I(2))                # Same process noise variance (could be random too)
C_init = randn(rng, obs_dim, latent_dim)   # Random observation mapping
R_init = Matrix(0.5 * I(obs_dim))          # Same observation noise (could vary)
x0_init = zeros(latent_dim)                # Start from origin
P0_init = Matrix(0.1 * I(latent_dim))      # Same initial uncertainty</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.1  0.0
 0.0  0.1</code></pre><p>Create the naive model components</p><pre><code class="language-julia hljs">gaussian_sm_init = GaussianStateModel(;A=A_init, Q=Q_init, x0=x0_init, P0=P0_init)
gaussian_om_init = GaussianObservationModel(;C=C_init, R=R_init)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GaussianObservationModel{Float64, Matrix{Float64}}([0.2065922420239735 -1.7114406178606316; -0.666067568704033 -0.6065105564709511; … ; -1.1839292234903664 -0.4467598454361075; -1.3669899015591334 1.574914773263386], [0.5 0.0 … 0.0 0.0; 0.0 0.5 … 0.0 0.0; … ; 0.0 0.0 … 0.5 0.0; 0.0 0.0 … 0.0 0.5])</code></pre><p>Assemble the complete naive system</p><pre><code class="language-julia hljs">naive_ssm = LinearDynamicalSystem(;
    state_model=gaussian_sm_init,
    obs_model=gaussian_om_init,
    latent_dim=latent_dim,
    obs_dim=obs_dim,
    fit_bool=fill(true, 6)  # We&#39;ll learn all parameters
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}(GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}([-0.8085867531718132 0.5883769732026107; 0.5883769732026107 0.8085867531718129], [0.1 0.0; 0.0 0.1], [0.0, 0.0], [0.1 0.0; 0.0 0.1]), GaussianObservationModel{Float64, Matrix{Float64}}([0.2065922420239735 -1.7114406178606316; -0.666067568704033 -0.6065105564709511; … ; -1.1839292234903664 -0.4467598454361075; -1.3669899015591334 1.574914773263386], [0.5 0.0 … 0.0 0.0; 0.0 0.5 … 0.0 0.0; … ; 0.0 0.0 … 0.5 0.0; 0.0 0.0 … 0.0 0.5]), 2, 10, Bool[1, 1, 1, 1, 1, 1])</code></pre><p>Before fitting, let&#39;s see how well our randomly initialized model can infer the latent states. We use the &quot;smoothing&quot; algorithm, which estimates the latent states given all observations (past, present, and future).</p><pre><code class="language-julia hljs">x_smooth, p_smooth = StateSpaceDynamics.smooth(naive_ssm, observations)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.1770898685592835 0.0022593349390950274 … -0.12646570518319003 0.43769022802313456; -0.03800344690033071 -0.04265287007320289 … 0.43238344213391694 0.1673561225991178;;;], [0.0371517218780309 -0.0002806875906856698; -0.0002806875906856698 0.018955781025515504;;; 0.04146507631271108 -0.0009300666295498139; -0.0009300666295498139 0.019863015981523083;;; 0.04198593299037335 -0.0010348238527923574; -0.0010348238527923574 0.01991732380516981;;; … ;;; 0.04228748041941903 -0.001086900580440355; -0.001086900580440355 0.019934254578118454;;; 0.04371192362863556 -0.001533854579023846; -0.001533854579023846 0.020240105373530607;;; 0.05911581001246951 -0.0005510798168893456; -0.0005510798168893456 0.02339133880005026;;;;])</code></pre><p>Plot the true latent states vs. our initial (poor) estimates</p><pre><code class="language-julia hljs">plot()
for d in 1:latent_dim
    plot!(1:tSteps, states[d, :] .+ lim_states * (d-1), color=:black, linewidth=2, label=&quot;&quot;, subplot=1)
    plot!(1:tSteps, x_smooth[d, :, 1] .+ lim_states * (d-1), color=:firebrick, linewidth=2, label=&quot;&quot;, subplot=1)
end
plot!(subplot=1, yticks=(lim_states .* (0:latent_dim-1), [L&quot;x_%$d&quot; for d in 1:latent_dim]),
      xticks=[], xlims=(0, tSteps), yformatter=y-&gt;&quot;&quot;, tickfontsize=12,
      title=&quot;True vs. Predicted Latent States (Pre-EM)&quot;)</code></pre><img src="3b55b3a7.svg" alt="Example block output"/><h2 id="Fit-Model-Using-EM-Algorithm"><a class="docs-heading-anchor" href="#Fit-Model-Using-EM-Algorithm">Fit Model Using EM Algorithm</a><a id="Fit-Model-Using-EM-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-Model-Using-EM-Algorithm" title="Permalink"></a></h2><p>Now comes the crucial step: parameter learning via the Expectation-Maximization (EM) algorithm. EM alternates between two steps:</p><ol><li>E-step: Estimate latent states given current parameters</li><li>M-step: Update parameters given current state estimates</li></ol><p>This process iteratively improves both the parameter estimates and state inferences.</p><pre><code class="language-julia hljs">println(&quot;Starting EM algorithm to learn parameters...&quot;)
elbo, _ = fit!(naive_ssm, observations; max_iter=100, tol=1e-6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-16920.34248093515, -8043.609594816091, -7944.281520058926, -7864.945696255579, -7803.771263699677, -7748.036226977818, -7675.662701190506, -7575.62794368438, -7464.925727564989, -7372.889050812913  …  -7268.875496045487, -7268.875350426761, -7268.875208217323, -7268.875069522952, -7268.874933779121, -7268.874801500497, -7268.874670989786, -7268.874544538528, -7268.874420781317, -7268.874299604732], [13.176403717373796, 2.439257149957197, 1.6452019433760112, 1.1400931472758378, 1.3074243978211186, 1.7602371338739968, 1.8955265986120235, 1.5336388006743162, 1.0037579133885373, 0.5730642819556486  …  1.911136790145294e-6, 1.8016477276457932e-6, 1.7518443282030753e-6, 1.6893612228634391e-6, 1.670101094431195e-6, 1.5993805394318728e-6, 1.6851176301876809e-6, 1.5474998327950292e-6, 1.5075695712282955e-6, 1.4838493422864334e-6])</code></pre><p>After EM has converged, let&#39;s see how much better our latent state estimates are</p><pre><code class="language-julia hljs">x_smooth, p_smooth = StateSpaceDynamics.smooth(naive_ssm, observations)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.3349743808637824 0.35106465738817694 … -0.01065423960556934 0.03385097547910517; -0.1487604379343402 -0.11357467303607487 … 0.3911880985190491 0.3755900793863628;;;], [0.00011162406483284527 -2.440356251469263e-6; -2.440356251469263e-6 4.090502022852363e-5;;; 0.007240095589622878 0.00011677251716901558; 0.00011677251716901558 0.0026861025772297025;;; 0.007870328216999201 9.40861081559934e-5; 9.40861081559934e-5 0.00288621802240352;;; … ;;; 0.007949091277582861 8.824610290381434e-5; 8.824610290381434e-5 0.0029070345146316656;;; 0.008124217031267292 7.67931567649365e-5; 7.67931567649365e-5 0.0029583750309796113;;; 0.010193493668882435 0.0001139135564637859; 0.0001139135564637859 0.0036013301409662953;;;;])</code></pre><p>Plot the results: true states vs. post-EM estimates</p><pre><code class="language-julia hljs">plot()
for d in 1:latent_dim
    plot!(1:tSteps, states[d, :] .+ lim_states * (d-1), color=:black, linewidth=2, label=&quot;&quot;, subplot=1)
    plot!(1:tSteps, x_smooth[d, :, 1] .+ lim_states * (d-1), color=:firebrick, linewidth=2, label=&quot;&quot;, subplot=1)
end
plot!(subplot=1, yticks=(lim_states .* (0:latent_dim-1), [L&quot;x_%$d&quot; for d in 1:latent_dim]),
      xticks=[], xlims=(0, tSteps), yformatter=y-&gt;&quot;&quot;, tickfontsize=12,
      title=&quot;True vs. Predicted Latent States (Post-EM)&quot;)</code></pre><img src="4349f669.svg" alt="Example block output"/><h2 id="Confirm-Model-Convergence"><a class="docs-heading-anchor" href="#Confirm-Model-Convergence">Confirm Model Convergence</a><a id="Confirm-Model-Convergence-1"></a><a class="docs-heading-anchor-permalink" href="#Confirm-Model-Convergence" title="Permalink"></a></h2><p>The Evidence Lower BOund (ELBO) is a measure of how well our model explains the data. In EM, this should increase monotonically and plateau when the algorithm has converged to a local optimum.</p><pre><code class="language-julia hljs">plot(elbo, xlabel=&quot;iteration&quot;, ylabel=&quot;ELBO&quot;, title=&quot;ELBO (Marginal Loglikelihood)&quot;, legend=false)

println(&quot;EM converged after $(length(elbo)) iterations&quot;)
println(&quot;Final ELBO: $(elbo[end])&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EM converged after 100 iterations
Final ELBO: -7268.874299604732</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial demonstrated the complete workflow for fitting a Linear Dynamical System:</p><ol><li>We defined a true LDS with known parameters and generated synthetic data</li><li>We initialized a naive model with random parameters</li><li>We used EM to iteratively improve our parameter estimates</li><li>We visualized how the latent state inference improved after learning</li></ol><p>The EM algorithm successfully recovered the underlying dynamics from observations alone, as evidenced by the improved match between true and estimated latent states and the convergence of the ELBO objective function.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../MixtureModels/">« Mixture Models</a><a class="docs-footer-nextpage" href="../poisson_latent_dynamics_example/">Poisson LDS Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 9 September 2025 14:35">Tuesday 9 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
