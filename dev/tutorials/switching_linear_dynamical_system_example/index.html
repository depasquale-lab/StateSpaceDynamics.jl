<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Switching Linear Dynamical System Example · StateSpaceDynamics.jl</title><meta name="title" content="Switching Linear Dynamical System Example · StateSpaceDynamics.jl"/><meta property="og:title" content="Switching Linear Dynamical System Example · StateSpaceDynamics.jl"/><meta property="twitter:title" content="Switching Linear Dynamical System Example · StateSpaceDynamics.jl"/><meta name="description" content="Documentation for StateSpaceDynamics.jl."/><meta property="og:description" content="Documentation for StateSpaceDynamics.jl."/><meta property="twitter:description" content="Documentation for StateSpaceDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../LinearDynamicalSystems/">Linear Dynamical Systems</a></li><li><a class="tocitem" href="../../HiddenMarkovModels/">Hidden Markov Models</a></li><li><a class="tocitem" href="../../SLDS/">Switching Linear Dynamical Systems</a></li><li><a class="tocitem" href="../../EmissionModels/">EmissionModels</a></li><li><a class="tocitem" href="../../MixtureModels/">Mixture Models</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../gaussian_latent_dynamics_example/">Gaussian LDS Example</a></li><li><a class="tocitem" href="../poisson_latent_dynamics_example/">Poisson LDS Example</a></li><li><a class="tocitem" href="../hidden_markov_model_example/">Hidden Markov Model Example</a></li><li><a class="tocitem" href="../gaussian_glm_hmm_example/">Gaussian GLM-GMM Example</a></li><li><a class="tocitem" href="../gaussian_mixture_model_example/">Gaussian Mixture Model Example</a></li><li><a class="tocitem" href="../poisson_mixture_model_example/">Poisson Mixture Model Example</a></li><li><a class="tocitem" href="../Probabilistic_PCA_example/">Probabilistic PCA Example</a></li><li class="is-active"><a class="tocitem" href>Switching Linear Dynamical System Example</a><ul class="internal"><li><a class="tocitem" href="#Model-overview"><span>Model overview</span></a></li><li><a class="tocitem" href="#Load-Packages"><span>Load Packages</span></a></li><li><a class="tocitem" href="#Simulate-data-from-an-SLDS"><span>Simulate data from an SLDS</span></a></li><li><a class="tocitem" href="#Plot-latent-dynamics-with-mode-shading"><span>Plot latent dynamics with mode shading</span></a></li><li><a class="tocitem" href="#Initialize-and-fit-an-SLDS-to-the-observations"><span>Initialize and fit an SLDS to the observations</span></a></li><li><a class="tocitem" href="#ELBO-over-iterations"><span>ELBO over iterations</span></a></li><li><a class="tocitem" href="#Compare-true-vs.-learned-latent-states"><span>Compare true vs. learned latent states</span></a></li><li><a class="tocitem" href="#Decoding-modes-and-basic-accuracy-metrics"><span>Decoding modes and basic accuracy metrics</span></a></li><li><a class="tocitem" href="#Practical-tips-and-pitfalls"><span>Practical tips &amp; pitfalls</span></a></li><li><a class="tocitem" href="#Exercises"><span>Exercises</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../Misc/">Miscellaneous</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Switching Linear Dynamical System Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Switching Linear Dynamical System Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/depasquale-lab/StateSpaceDynamics.jl/blob/main/docs/examples/SLDS.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Simulating-and-Fitting-a-Switching-Linear-Dynamical-System-(SLDS)"><a class="docs-heading-anchor" href="#Simulating-and-Fitting-a-Switching-Linear-Dynamical-System-(SLDS)">Simulating and Fitting a Switching Linear Dynamical System (SLDS)</a><a id="Simulating-and-Fitting-a-Switching-Linear-Dynamical-System-(SLDS)-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-and-Fitting-a-Switching-Linear-Dynamical-System-(SLDS)" title="Permalink"></a></h1><p>This tutorial walks through building, simulating, and fitting a <strong>Switching Linear Dynamical System (SLDS)</strong> with <code>StateSpaceDynamics.jl</code>. SLDS combines a discrete Hidden Markov Model (HMM) over modes with a set of linear-Gaussian state-space models (one per mode). It captures time series that switch among distinct linear dynamics (e.g., slow vs. fast oscillators).</p><h2 id="Model-overview"><a class="docs-heading-anchor" href="#Model-overview">Model overview</a><a id="Model-overview-1"></a><a class="docs-heading-anchor-permalink" href="#Model-overview" title="Permalink"></a></h2><p>The SLDS has:</p><ul><li>Discrete mode (s<em>t \in {1,\dots,K}) with Markov dynamics (p(s</em>t\mid s<em>{t-1}) = A</em>{\text{hmm}}[s<em>{t-1}, s</em>t]), initial (\pi_0).</li><li>Continuous latent state (x<em>t \in \mathbb R^{d</em>x}) evolving as (x<em>t = A</em>{s<em>t} x</em>{t-1} + \varepsilon<em>t), with (\varepsilon</em>t \sim \mathcal N(0, Q<em>{s</em>t})).</li><li>Observations (y<em>t \in \mathbb R^{d</em>y}) via (y<em>t = C</em>{s<em>t} x</em>t + \eta<em>t), with (\eta</em>t \sim \mathcal N(0, R<em>{s</em>t})).</li><li>Initial distribution (x<em>0 \sim \mathcal N(\mu</em>0, P_0)).</li></ul><p><strong>Inference &amp; learning.</strong> Exact EM is intractable because of the exponential number of mode sequences. <code>fit!</code> uses a structured variational EM: a forward– backward step for the HMM (variational E-step) coupled with Kalman smoothing in each mode (continuous E-step), followed by M-step updates of parameters. The objective reported as <code>mls</code> is an ELBO that should increase monotonically.</p><hr/><h2 id="Load-Packages"><a class="docs-heading-anchor" href="#Load-Packages">Load Packages</a><a id="Load-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using StateSpaceDynamics
using LinearAlgebra
using Random
using Plots
using LaTeXStrings
using Statistics
using StableRNGs

rng = StableRNG(123);</code></pre><h2 id="Simulate-data-from-an-SLDS"><a class="docs-heading-anchor" href="#Simulate-data-from-an-SLDS">Simulate data from an SLDS</a><a id="Simulate-data-from-an-SLDS-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-data-from-an-SLDS" title="Permalink"></a></h2><pre><code class="language-julia hljs">state_dim = 2
obs_dim   = 10
K         = 2  # two modes</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>HMM (mode) parameters</p><pre><code class="language-julia hljs">A_hmm = [0.92 0.08; 0.06 0.94]
π₀    = [1.0, 0.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 1.0
 0.0</code></pre><p>Mode-specific state dynamics (two oscillators)</p><pre><code class="language-julia hljs">A₁ = 0.95 * [cos(0.05) -sin(0.05); sin(0.05) cos(0.05)]  # slower
A₂ = 0.95 * [cos(0.55) -sin(0.55); sin(0.55) cos(0.55)]  # faster

Q₁ = [0.001 0.0; 0.0 0.001]
Q₂ = [0.1   0.0; 0.0 0.1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.1  0.0
 0.0  0.1</code></pre><p>Shared initial state distribution for simplicity</p><pre><code class="language-julia hljs">x0 = [0.0, 0.0]
P0 = [0.1 0.0; 0.0 0.1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.1  0.0
 0.0  0.1</code></pre><p>Mode-specific observation models</p><pre><code class="language-julia hljs">C₁ = randn(rng, obs_dim, state_dim)
C₂ = randn(rng, obs_dim, state_dim)
R  = Matrix(0.1 * I(obs_dim))  # shared observation noise

model = SwitchingLinearDynamicalSystem(
    A_hmm,
    [
        LinearDynamicalSystem(GaussianStateModel(A₁, Q₁, x0, P0), GaussianObservationModel(C₁, R), state_dim, obs_dim, fill(true, 6)),
        LinearDynamicalSystem(GaussianStateModel(A₂, Q₂, x0, P0), GaussianObservationModel(C₂, R), state_dim, obs_dim, fill(true, 6)),
    ],
    π₀,
    K,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SwitchingLinearDynamicalSystem{Float64, Matrix{Float64}, Vector{Float64}, Vector{LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}}}([0.92 0.08; 0.06 0.94], LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}[LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}(GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}([0.9488127473752179 -0.04748021080714441; 0.04748021080714441 0.9488127473752179], [0.001 0.0; 0.0 0.001], [0.0, 0.0], [0.1 0.0; 0.0 0.1]), GaussianObservationModel{Float64, Matrix{Float64}}([-0.12683768965424458 -0.9995722599695167; 0.6668851724871252 -1.4919831226368483; … ; -0.9671975288083468 -0.3274601670258862; -1.3641880343579902 -0.5067518363436612], [0.1 0.0 … 0.0 0.0; 0.0 0.1 … 0.0 0.0; … ; 0.0 0.0 … 0.1 0.0; 0.0 0.0 … 0.0 0.1]), 2, 10, Bool[1, 1, 1, 1, 1, 1]), LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}(GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}([0.8098982959565304 -0.49655286748412625; 0.49655286748412625 0.8098982959565304], [0.1 0.0; 0.0 0.1], [0.0, 0.0], [0.1 0.0; 0.0 0.1]), GaussianObservationModel{Float64, Matrix{Float64}}([1.0443142059889696 -0.5347108765515856; -1.0054987763056575 -1.3326214710879172; … ; 0.18175657498076916 0.7664332603207097; -0.6932386774034219 1.5864122760678063], [0.1 0.0 … 0.0 0.0; 0.0 0.1 … 0.0 0.0; … ; 0.0 0.0 … 0.1 0.0; 0.0 0.0 … 0.0 0.1]), 2, 10, Bool[1, 1, 1, 1, 1, 1])], [1.0, 0.0], 2)</code></pre><p>Simulate</p><pre><code class="language-julia hljs">T = 1000
x, y, z = rand(rng, model, T)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-0.0076254535387565315 -0.026736950421509708 … -0.20851593522388234 -0.8831797533183605; -0.04123506436656016 -0.04968386920475945 … 1.1862497026616088 0.6293615983570888], [-0.18526210459309506 -0.06433430286900964 … -0.8098182791936162 -1.4859485956773404; 0.3217524900300324 -0.12040330256520651 … -1.210732098099335 0.35577503667808597; … ; -0.07844180835082344 0.2019329716852997 … 0.3839890381264888 0.44105347634109915; 0.49270132361714775 0.10348607980768684 … 1.896939242639954 1.3110786965259218], [1, 1, 1, 1, 1, 1, 2, 2, 2, 2  …  2, 2, 2, 2, 2, 2, 2, 2, 2, 2])</code></pre><h2 id="Plot-latent-dynamics-with-mode-shading"><a class="docs-heading-anchor" href="#Plot-latent-dynamics-with-mode-shading">Plot latent dynamics with mode shading</a><a id="Plot-latent-dynamics-with-mode-shading-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-latent-dynamics-with-mode-shading" title="Permalink"></a></h2><pre><code class="language-julia hljs">p1 = plot(1:T, x[1, :], label=&quot;x₁&quot;, linewidth=1.5)
plot!(1:T, x[2, :], label=&quot;x₂&quot;, linewidth=1.5)</code></pre><img src="55e27b64.svg" alt="Example block output"/><p>Shade regions by discrete mode z</p><pre><code class="language-julia hljs">transition_points = [1; findall(diff(z) .!= 0) .+ 1; T + 1]
for i in 1:(length(transition_points) - 1)
    start_idx = transition_points[i]
    end_idx   = transition_points[i + 1] - 1
    state_val = z[start_idx]
    bg_color  = state_val == 1 ? :lightblue : :lightyellow
    vspan!([start_idx, end_idx], fillalpha=0.5, color=bg_color, label=(i == 1 ? &quot;State $state_val&quot; : &quot;&quot;))
end

title!(&quot;Latent Dynamics with Mode Shading&quot;)
xlabel!(&quot;Time&quot;)
ylabel!(&quot;State Value&quot;)
ylims!(-3, 3)

p1</code></pre><img src="ce443738.svg" alt="Example block output"/><h2 id="Initialize-and-fit-an-SLDS-to-the-observations"><a class="docs-heading-anchor" href="#Initialize-and-fit-an-SLDS-to-the-observations">Initialize and fit an SLDS to the observations</a><a id="Initialize-and-fit-an-SLDS-to-the-observations-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-and-fit-an-SLDS-to-the-observations" title="Permalink"></a></h2><p>Good initialization helps. We&#39;ll set a moderately sticky HMM and rough dynamics, then call <code>fit!</code> for variational EM.</p><pre><code class="language-julia hljs">A = [0.9 0.1; 0.1 0.9]
A ./= sum(A, dims=2)   # row-stochastic

πₖ = rand(rng, K); πₖ ./= sum(πₖ)

Q  = Matrix(0.001 * I(state_dim))
P0 = Matrix(0.001 * I(state_dim))
C  = randn(rng, obs_dim, state_dim)
R  = Matrix(0.1 * I(obs_dim))

B = [
    LinearDynamicalSystem(
        GaussianStateModel(0.95 * [cos(f) -sin(f); sin(f) cos(f)], Q, x0, P0),
        GaussianObservationModel(C, R),
        state_dim, obs_dim, fill(true, 6),
    ) for f in (0.7, 0.1)
]

learned_model = SwitchingLinearDynamicalSystem(A, B, πₖ, K)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SwitchingLinearDynamicalSystem{Float64, Matrix{Float64}, Vector{Float64}, Vector{LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}}}([0.9 0.1; 0.1 0.9], LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}[LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}(GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}([0.726600077920264 -0.6120068028758064; 0.6120068028758064 0.726600077920264], [0.001 0.0; 0.0 0.001], [0.0, 0.0], [0.001 0.0; 0.0 0.001]), GaussianObservationModel{Float64, Matrix{Float64}}([-0.4266281367539621 0.2893604859023665; 2.0558534609423984 0.2460882575988024; … ; -0.19054205642032404 0.395709505567462; 0.8072263951276352 0.9875150016432166], [0.1 0.0 … 0.0 0.0; 0.0 0.1 … 0.0 0.0; … ; 0.0 0.0 … 0.1 0.0; 0.0 0.0 … 0.0 0.1]), 2, 10, Bool[1, 1, 1, 1, 1, 1]), LinearDynamicalSystem{Float64, GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}, GaussianObservationModel{Float64, Matrix{Float64}}}(GaussianStateModel{Float64, Matrix{Float64}, Vector{Float64}}([0.9452539570141245 -0.09484174581448675; 0.09484174581448675 0.9452539570141245], [0.001 0.0; 0.0 0.001], [0.0, 0.0], [0.001 0.0; 0.0 0.001]), GaussianObservationModel{Float64, Matrix{Float64}}([-0.4266281367539621 0.2893604859023665; 2.0558534609423984 0.2460882575988024; … ; -0.19054205642032404 0.395709505567462; 0.8072263951276352 0.9875150016432166], [0.1 0.0 … 0.0 0.0; 0.0 0.1 … 0.0 0.0; … ; 0.0 0.0 … 0.1 0.0; 0.0 0.0 … 0.0 0.1]), 2, 10, Bool[1, 1, 1, 1, 1, 1])], [0.5875442206416667, 0.4124557793583333], 2)</code></pre><p>Fit with variational EM</p><pre><code class="language- hljs">mls, param_diff, FB, FS = fit!(learned_model, y; max_iter=25)</code></pre><p><code>mls</code> is the ELBO trace; <code>param_diff</code> can be used as an additional stopping metric if desired; <code>FB</code> holds HMM posteriors and <code>FS</code> holds per-mode Kalman smoothing.</p><h2 id="ELBO-over-iterations"><a class="docs-heading-anchor" href="#ELBO-over-iterations">ELBO over iterations</a><a id="ELBO-over-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#ELBO-over-iterations" title="Permalink"></a></h2><pre><code class="language- hljs">plot(mls, label=&quot;ELBO&quot;, linewidth=1.5)
xlabel!(&quot;Iteration&quot;)
ylabel!(&quot;ELBO&quot;)</code></pre><h2 id="Compare-true-vs.-learned-latent-states"><a class="docs-heading-anchor" href="#Compare-true-vs.-learned-latent-states">Compare true vs. learned latent states</a><a id="Compare-true-vs.-learned-latent-states-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-true-vs.-learned-latent-states" title="Permalink"></a></h2><p>We combine mode-specific smoothed states using HMM responsibilities as weights.</p><pre><code class="language- hljs">latents = zeros(state_dim, T)
resp    = exp.(FB.γ)
for t in 1:T
    for k in 1:K
        latents[:, t] += FS[k].x_smooth[:, t] .* resp[k, t]
    end
end

plt = plot(size=(800, 500), background_color=:white, margin=5Plots.mm)
plot!(x[1, :] .+ 2, label=&quot;x₁ (True)&quot;,   linewidth=2, color=:black,    alpha=0.8)
plot!(x[2, :] .- 2, label=&quot;x₂ (True)&quot;,   linewidth=2, color=:black,    alpha=0.8)
plot!(latents[1, :] .+ 2, label=&quot;x₁ (Learned)&quot;, linewidth=1.5, color=:firebrick)
plot!(latents[2, :] .- 2, label=&quot;x₂ (Learned)&quot;, linewidth=1.5, color=:royalblue)

title!(&quot;SLDS: True vs Learned Latent States&quot;)
xlabel!(&quot;Time&quot;)
ylabel!(&quot;&quot;)
yticks!([-2, 2], [&quot;x₂&quot;, &quot;x₁&quot;])
hline!([2],  color=:gray, alpha=0.3, linestyle=:dash, label=&quot;&quot;)
hline!([-2], color=:gray, alpha=0.3, linestyle=:dash, label=&quot;&quot;)
xlims!(0, T)

plt</code></pre><h2 id="Decoding-modes-and-basic-accuracy-metrics"><a class="docs-heading-anchor" href="#Decoding-modes-and-basic-accuracy-metrics">Decoding modes and basic accuracy metrics</a><a id="Decoding-modes-and-basic-accuracy-metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Decoding-modes-and-basic-accuracy-metrics" title="Permalink"></a></h2><p>Hard-decoded modes by argmax responsibilities, and a simple confusion rate with the simulated ground truth (up to label permutation).</p><pre><code class="language- hljs">z_hat = map(t -&gt; argmax(view(resp, :, t)), 1:T)</code></pre><p>Since labels are arbitrary, align them to best match truth via a 2x2 sweep.</p><pre><code class="language- hljs">function align_labels_2way(z_true::AbstractVector{&lt;:Integer}, z_pred::AbstractVector{&lt;:Integer})
    acc1 = mean(z_true .== z_pred)
    acc2 = mean(z_true .== (3 .- z_pred))  # flip 1&lt;-&gt;2
    if acc2 &gt; acc1
        return (3 .- z_pred), acc2
    else
        return z_pred, acc1
    end
end

z_aligned, acc = align_labels_2way(vec(z), z_hat)
@info &quot;Mode decoding accuracy (up to permutation)&quot; acc</code></pre><h2 id="Practical-tips-and-pitfalls"><a class="docs-heading-anchor" href="#Practical-tips-and-pitfalls">Practical tips &amp; pitfalls</a><a id="Practical-tips-and-pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-tips-and-pitfalls" title="Permalink"></a></h2><ul><li><strong>Stickiness:</strong> If modes switch too frequently, increase self-transition mass in A_hmm or add a stickiness prior in the M-step.</li><li><strong>Scaling/identifiability:</strong> With per-mode C, Q, R all free, degeneracies can appear. Consider tying certain parameters across modes (e.g., shared R).</li><li><strong>Initialization:</strong> Seed A<em>hmm near diagonal; initialize A</em>k with different frequencies/directions to avoid identical modes; run from multiple starts.</li><li><strong>Diagnostics:</strong> Monitor ELBO and parameter differences; visualize responsibilities over time and check that each mode explains distinct dynamics.</li></ul><h2 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h2><ol><li>Increase K to 3 and create a third oscillator; verify that modes separate.</li><li>Make R state-specific and observe the tradeoff between Q and R in explaining variability.</li><li>Start from nearly identical A<em>k and show that without good initialization the model collapses to a single effective mode; then fix with sticky A</em>hmm.</li><li>Plot the responsibilities <code>resp[k, :]</code> over time and compare against ground truth.</li></ol><hr/><p>End of tutorial.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Probabilistic_PCA_example/">« Probabilistic PCA Example</a><a class="docs-footer-nextpage" href="../../Misc/">Miscellaneous »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 9 September 2025 00:20">Tuesday 9 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
